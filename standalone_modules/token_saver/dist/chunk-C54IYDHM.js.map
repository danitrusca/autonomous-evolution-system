{"version":3,"sources":["../src/utils/io.ts","../src/estimators/heuristic.ts","../src/utils/eol.ts","../src/utils/unicode.ts","../src/json-minify.ts","../src/diff.ts","../src/strip-fillers/presets.ts","../src/strip-fillers/engine.ts","../src/optimizers/semantic-compression.ts","../src/optimizers/whitespace-compression.ts","../src/optimizers/duplicate-detection.ts","../src/optimizers/content-type-detection.ts","../src/optimizers/summarization.ts","../src/optimizers/context-specific.ts","../src/optimizers/cache.ts","../src/optimizers/advanced-engine.ts","../src/cli.ts"],"sourcesContent":["import fs from \"node:fs\";\r\nimport path from \"node:path\";\r\n\r\nexport function readStdinSync(): string {\r\n  const fd = 0; // stdin\r\n  try {\r\n    if (fs.fstatSync(fd).isFIFO() || fs.fstatSync(fd).isFile()) {\r\n      return fs.readFileSync(fd, \"utf8\");\r\n    }\r\n  } catch {}\r\n  return \"\";\r\n}\r\n\r\nexport function readFileText(p: string): string {\r\n  return fs.readFileSync(p, \"utf8\");\r\n}\r\n\r\nexport function writeFileText(p: string, data: string): void {\r\n  const dir = path.dirname(p);\r\n  fs.mkdirSync(dir, { recursive: true });\r\n  fs.writeFileSync(p, data, \"utf8\");\r\n}\r\n\r\n","const CHAR_PER_TOKEN: Record<string, number> = {\r\n  \"gpt-4o-mini\": 4.0,\r\n  \"gpt-4.1\": 3.7,\r\n  \"claude-3.5\": 3.8,\r\n  \"gemini-1.5\": 3.9,\r\n  \"generic\": 4.0\r\n};\r\n\r\nexport interface EstimateOptions {\r\n  model?: string;\r\n  diffHeuristicBump?: boolean; // +15% for symbol-dense diffs when true\r\n}\r\n\r\nexport function estimateTokensHeuristic(text: string, opts: EstimateOptions = {}) {\r\n  const model = opts.model && CHAR_PER_TOKEN[opts.model] ? opts.model : \"generic\";\r\n  const chars = text.length;\r\n  const ratio = CHAR_PER_TOKEN[model];\r\n  let tokens = Math.ceil(chars / ratio);\r\n  let note: string | undefined;\r\n  if (opts.diffHeuristicBump) {\r\n    tokens = Math.ceil(tokens * 1.15);\r\n    note = \"Heuristic â€“ Code Context\";\r\n  }\r\n  return { chars, tokens, model, note } as const;\r\n}\r\n\r\n","export type EOL = \"\\n\" | \"\\r\\n\" | \"\\r\";\r\n\r\nexport function detectEol(text: string): EOL {\r\n  const idx = text.indexOf(\"\\n\");\r\n  if (idx === -1) return text.indexOf(\"\\r\") !== -1 ? \"\\r\" : \"\\n\";\r\n  return text[idx - 1] === \"\\r\" ? \"\\r\\n\" : \"\\n\";\r\n}\r\n\r\nexport function normalizeEol(text: string, keepEol: boolean): { text: string; eol: EOL } {\r\n  if (!text) return { text, eol: \"\\n\" };\r\n  const original = detectEol(text);\r\n  if (keepEol) return { text, eol: original };\r\n  const unified = text.replace(/\\r\\n?|\\n/g, \"\\n\");\r\n  return { text: unified, eol: \"\\n\" };\r\n}\r\n\r\n","export function normalizeNFC(text: string): string {\r\n  return text.normalize(\"NFC\");\r\n}\r\n\r\n","import { normalizeEol } from \"./utils/eol.js\";\r\nimport { normalizeNFC } from \"./utils/unicode.js\";\r\n\r\nexport interface JsonMinifyOptions {\r\n  keepEol?: boolean;\r\n  maxBytes?: number; // default 32MB\r\n}\r\n\r\nexport interface TransformResult {\r\n  output: string;\r\n  meta: { changed: boolean; preserved: { codeBlocks: number; inline: number; json: boolean } };\r\n}\r\n\r\nconst DEFAULT_MAX = 32 * 1024 * 1024; // 32MB\r\n\r\nexport function jsonMinify(input: string, opts: JsonMinifyOptions = {}): TransformResult {\r\n  const maxBytes = opts.maxBytes ?? DEFAULT_MAX;\r\n  const { text } = normalizeEol(normalizeNFC(input), !!opts.keepEol);\r\n  if (Buffer.byteLength(text, \"utf8\") > maxBytes) {\r\n    const err = new Error(\"Input exceeds size limit\");\r\n    // @ts-expect-error brand\r\n    err.code = 1;\r\n    throw err;\r\n  }\r\n\r\n  const trimmed = text.trim();\r\n  // NDJSON detection: multiple lines of JSON objects/arrays/primitives\r\n  const isNdjson = trimmed.includes(\"\\n\");\r\n\r\n  try {\r\n    if (!isNdjson) {\r\n      const parsed = JSON.parse(trimmed);\r\n      const min = JSON.stringify(parsed);\r\n      return {\r\n        output: min,\r\n        meta: { changed: min !== trimmed, preserved: { codeBlocks: 0, inline: 0, json: true } }\r\n      };\r\n    }\r\n\r\n    const lines = text.split(\"\\n\");\r\n    const out: string[] = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      if (line === \"\") { out.push(\"\"); continue; }\r\n      try {\r\n        const parsed = JSON.parse(line);\r\n        out.push(JSON.stringify(parsed));\r\n      } catch (e) {\r\n        const msg = (e as Error).message || \"Invalid JSON\";\r\n        const err = new Error(`Invalid NDJSON at line ${i + 1}: ${msg}`);\r\n        // @ts-expect-error brand\r\n        err.code = 2;\r\n        throw err;\r\n      }\r\n    }\r\n    const joined = out.join(\"\\n\");\r\n    return { output: joined, meta: { changed: joined !== text, preserved: { codeBlocks: 0, inline: 0, json: true } } };\r\n  } catch (e) {\r\n    if ((e as any)?.code === 2) throw e;\r\n    const message = (e as Error).message || \"Invalid JSON\";\r\n    const err = new Error(`Invalid JSON: ${message}`);\r\n    // @ts-expect-error brand\r\n    err.code = 2;\r\n    throw err;\r\n  }\r\n}\r\n\r\n","import { createTwoFilesPatch } from \"diff\";\r\nimport { normalizeEol } from \"./utils/eol.js\";\r\nimport { normalizeNFC } from \"./utils/unicode.js\";\r\n\r\nexport interface DiffOptions {\r\n  keepEol?: boolean;\r\n}\r\n\r\nexport function unifiedDiff(beforeName: string, before: string, afterName: string, after: string, opts: DiffOptions = {}): string {\r\n  const a = normalizeEol(normalizeNFC(before), !!opts.keepEol).text;\r\n  const b = normalizeEol(normalizeNFC(after), !!opts.keepEol).text;\r\n  const patch = createTwoFilesPatch(\"before\", \"after\", a, b, undefined, undefined, { context: 3 });\r\n  // Normalize headers\r\n  return patch\r\n    .replace(/^--- .*/m, \"--- before\")\r\n    .replace(/^\\+\\+\\+ .*/m, \"+++ after\");\r\n}\r\n\r\n","export type Preset = \"conservative\" | \"standard\" | \"aggressive\" | \"ultra\";\r\n\r\n// Patterns as tuples: [regex, replacement]\r\n// Ordered from specific to general.\r\nexport function getPresetPatterns(preset: Preset): Array<[RegExp, string]> {\r\n  const base: Array<[RegExp, string]> = [\r\n    [/\\bin order to\\b/gi, \"to\"],\r\n    [/\\bdue to the fact that\\b/gi, \"because\"],\r\n    [/\\bit'?s important to note( that)?\\b/gi, \"\"],\r\n    [/\\bat the end of the day\\b/gi, \"\"],\r\n    [/^\\s*I(?:\\s+personally)?\\s+think(?:\\s+that)?\\b/gi, \"\"],\r\n  ];\r\n  const standard: Array<[RegExp, string]> = [\r\n    [/\\bbasically\\b,?\\s*/gi, \"\"],\r\n    [/\\bactually\\b,?\\s*/gi, \"\"],\r\n    [/\\bsimply\\b,?\\s*/gi, \"\"],\r\n    [/\\bin fact\\b,?\\s*/gi, \"\"],\r\n    [/\\bneedless to say\\b,?\\s*/gi, \"\"],\r\n    [/\\bas you can see\\b,?\\s*/gi, \"\"],\r\n    [/\\bin a nutshell\\b,?\\s*/gi, \"\"],\r\n    [/\\bfor the most part\\b,?\\s*/gi, \"\"],\r\n    [/\\bthe truth is(?: that)?\\b,?\\s*/gi, \"\"],\r\n    [/\\bkind of\\b\\s*/gi, \"\"],\r\n    [/\\bsort of\\b\\s*/gi, \"\"],\r\n  ];\r\n  const aggressive: Array<[RegExp, string]> = [\r\n    [/\\bobviously\\b,?\\s*/gi, \"\"],\r\n    [/\\bliterally\\b,?\\s*/gi, \"\"],\r\n    [/\\bin my opinion\\b,?\\s*/gi, \"\"],\r\n    [/\\bto be honest\\b,?\\s*/gi, \"\"],\r\n    [/\\bIMO\\b,?\\s*/g, \"\"],\r\n    [/\\bTBH\\b,?\\s*/g, \"\"],\r\n  ];\r\n  const ultra: Array<[RegExp, string]> = [\r\n    [/\\bwhat I mean is\\b/gi, \"\"],\r\n    [/\\bthe thing is\\b/gi, \"\"],\r\n    [/\\bwhat I'm saying is\\b/gi, \"\"],\r\n    [/\\bif you will\\b/gi, \"\"],\r\n    [/\\bas it were\\b/gi, \"\"],\r\n    [/\\byou know\\b/gi, \"\"],\r\n    [/\\bI mean\\b/gi, \"\"],\r\n    [/\\byou see\\b/gi, \"\"],\r\n    [/\\bof course\\b/gi, \"\"],\r\n    [/\\bas you know\\b/gi, \"\"],\r\n    [/\\bit likely that\\b/gi, \"likely\"],\r\n    [/\\bfor all intents and purposes\\b/gi, \"\"],\r\n    [/\\bmake sure to\\b/gi, \"must\"],\r\n    [/\\bkeep in mind that\\b/gi, \"\"],\r\n    [/\\bwhen it comes to\\b/gi, \"for\"],\r\n    [/\\bprior to\\b/gi, \"before\"],\r\n    [/\\bsubsequent to\\b/gi, \"after\"],\r\n    [/\\bin the event that\\b/gi, \"if\"],\r\n    [/\\bwith regard to\\b/gi, \"about\"],\r\n    [/\\bin terms of\\b/gi, \"for\"],\r\n    [/\\bin the case of\\b/gi, \"for\"],\r\n    [/\\bin the context of\\b/gi, \"in\"],\r\n    [/\\bwith respect to\\b/gi, \"for\"],\r\n    [/\\bin relation to\\b/gi, \"about\"],\r\n    [/\\bas far as\\b/gi, \"for\"],\r\n    [/\\bmore often than not\\b/gi, \"usually\"],\r\n    [/\\bat this point in time\\b/gi, \"now\"],\r\n    [/\\bin the near future\\b/gi, \"soon\"],\r\n    [/\\bat the present time\\b/gi, \"now\"],\r\n  ];\r\n  if (preset === \"conservative\") return base;\r\n  if (preset === \"standard\") return base.concat(standard);\r\n  if (preset === \"aggressive\") return base.concat(standard, aggressive);\r\n  return base.concat(standard, aggressive, ultra);\r\n}\r\n\r\n","import { normalizeEol } from \"../utils/eol.js\";\r\nimport { normalizeNFC } from \"../utils/unicode.js\";\r\nimport { getPresetPatterns, Preset } from \"./presets.js\";\r\n\r\nexport interface StripOptions {\r\n  preset?: Preset;\r\n  keepEol?: boolean;\r\n}\r\n\r\nexport interface StripResult {\r\n  output: string;\r\n  meta: { changed: boolean; preserved: { codeBlocks: number; inline: number; json: boolean } };\r\n}\r\n\r\nfunction isLikelyJson(text: string): boolean {\r\n  const t = text.trim();\r\n  if (!(t.startsWith(\"{\") || t.startsWith(\"[\"))) return false;\r\n  try { JSON.parse(t); return true; } catch { return false; }\r\n}\r\n\r\n// Three-state scanner: TEXT / FENCED / INLINE\r\nexport function stripFillers(input: string, opts: StripOptions = {}): StripResult {\r\n  const { text } = normalizeEol(normalizeNFC(input), !!opts.keepEol);\r\n  if (isLikelyJson(text)) {\r\n    return { output: text, meta: { changed: false, preserved: { codeBlocks: 0, inline: 0, json: true } } };\r\n  }\r\n  const preset = opts.preset ?? \"conservative\";\r\n  const patterns = getPresetPatterns(preset);\r\n\r\n  const lines = text.split(\"\\n\");\r\n  let inFence = false;\r\n  let fenceCount = 0;\r\n  let inlineCount = 0;\r\n  const out: string[] = [];\r\n\r\n  for (const line of lines) {\r\n    if (line.trim().startsWith(\"```\")) {\r\n      inFence = !inFence;\r\n      if (inFence) fenceCount++;\r\n      out.push(line);\r\n      continue;\r\n    }\r\n    if (inFence) { out.push(line); continue; }\r\n\r\n    // Protect inline `code`\r\n    const segments: string[] = [];\r\n    const parts = line.split(/(`[^`]*`)/g);\r\n    for (let i = 0; i < parts.length; i++) {\r\n      const seg = parts[i];\r\n      const isInline = seg.startsWith(\"`\") && seg.endsWith(\"`\");\r\n      if (isInline) { segments.push(seg); inlineCount++; continue; }\r\n      let s = seg;\r\n      // Adverb adjacency guard near inline code: preserve just/really/very if next to inline span\r\n      const left = i > 0 && parts[i - 1].startsWith(\"`\");\r\n      const right = i < parts.length - 1 && parts[i + 1].startsWith(\"`\");\r\n      if (!(left || right)) {\r\n        for (const [re, rep] of patterns) {\r\n          s = s.replace(re, rep);\r\n        }\r\n      }\r\n      segments.push(s);\r\n    }\r\n    out.push(segments.join(\"\"));\r\n  }\r\n\r\n  const result = out.join(\"\\n\");\r\n  return {\r\n    output: result,\r\n    meta: { changed: result !== text, preserved: { codeBlocks: fenceCount, inline: inlineCount, json: false } }\r\n  };\r\n}\r\n\r\n","/**\r\n * Semantic Compression\r\n * \r\n * Replaces verbose phrases with concise equivalents while preserving meaning.\r\n * This provides significant token savings on formal or verbose text.\r\n */\r\n\r\nexport interface SemanticCompressionResult {\r\n  output: string;\r\n  replacements: number;\r\n}\r\n\r\nconst semanticReplacements: Array<[RegExp, string]> = [\r\n  // Verb replacements\r\n  [/\\bperform an analysis of\\b/gi, \"analyze\"],\r\n  [/\\bconduct a review of\\b/gi, \"review\"],\r\n  [/\\bcarry out an examination of\\b/gi, \"examine\"],\r\n  [/\\bundertake a study of\\b/gi, \"study\"],\r\n  [/\\bcarry out\\b/gi, \"do\"],\r\n  [/\\bperform\\b/gi, \"do\"],\r\n  [/\\bconduct\\b/gi, \"do\"],\r\n  \r\n  // Ability phrases\r\n  [/\\bhave the ability to\\b/gi, \"can\"],\r\n  [/\\bis able to\\b/gi, \"can\"],\r\n  [/\\bis capable of\\b/gi, \"can\"],\r\n  [/\\bis in a position to\\b/gi, \"can\"],\r\n  [/\\bhas the capacity to\\b/gi, \"can\"],\r\n  \r\n  // Time phrases\r\n  [/\\bin the process of\\b/gi, \"\"],\r\n  [/\\bat this point in time\\b/gi, \"now\"],\r\n  [/\\bat the present time\\b/gi, \"now\"],\r\n  [/\\bat this moment in time\\b/gi, \"now\"],\r\n  [/\\bin the near future\\b/gi, \"soon\"],\r\n  [/\\bat a later date\\b/gi, \"later\"],\r\n  \r\n  // Prepositional phrases\r\n  [/\\bby means of\\b/gi, \"via\"],\r\n  [/\\bin the vicinity of\\b/gi, \"near\"],\r\n  [/\\bfor the purpose of\\b/gi, \"for\"],\r\n  [/\\bin a timely manner\\b/gi, \"quickly\"],\r\n  [/\\bwith the exception of\\b/gi, \"except\"],\r\n  [/\\bin the case of\\b/gi, \"for\"],\r\n  [/\\bin the context of\\b/gi, \"in\"],\r\n  [/\\bwith respect to\\b/gi, \"for\"],\r\n  [/\\bin relation to\\b/gi, \"about\"],\r\n  [/\\bas far as\\b/gi, \"for\"],\r\n  \r\n  // Redundant phrases\r\n  [/\\bmore often than not\\b/gi, \"usually\"],\r\n  [/\\bthe majority of\\b/gi, \"most\"],\r\n  [/\\ba number of\\b/gi, \"many\"],\r\n  [/\\ba lot of\\b/gi, \"many\"],\r\n  [/\\ba great deal of\\b/gi, \"much\"],\r\n  [/\\ba large amount of\\b/gi, \"much\"],\r\n  [/\\ba small number of\\b/gi, \"few\"],\r\n  \r\n  // Unnecessary qualifiers\r\n  [/\\bvery much\\b/gi, \"much\"],\r\n  [/\\bquite a lot\\b/gi, \"many\"],\r\n  [/\\brather than\\b/gi, \"than\"],\r\n  \r\n  // Common verbose constructions\r\n  [/\\bit is worth noting that\\b/gi, \"\"],\r\n  [/\\bit should be noted that\\b/gi, \"\"],\r\n  [/\\bit is important to remember that\\b/gi, \"\"],\r\n  [/\\bit is essential to\\b/gi, \"must\"],\r\n  [/\\bit is necessary to\\b/gi, \"must\"],\r\n  [/\\bit is required to\\b/gi, \"must\"],\r\n];\r\n\r\nexport function applySemanticCompression(input: string): SemanticCompressionResult {\r\n  let output = input;\r\n  let replacements = 0;\r\n  \r\n  for (const [pattern, replacement] of semanticReplacements) {\r\n    const before = output;\r\n    output = output.replace(pattern, replacement);\r\n    if (output !== before) {\r\n      replacements++;\r\n    }\r\n  }\r\n  \r\n  return {\r\n    output,\r\n    replacements\r\n  };\r\n}\r\n\r\n","/**\r\n * Whitespace Compression\r\n * \r\n * Intelligently compresses whitespace while preserving readability and code structure.\r\n * Protects code blocks and inline code from compression.\r\n */\r\n\r\nexport interface WhitespaceCompressionResult {\r\n  output: string;\r\n  compressed: boolean;\r\n}\r\n\r\n/**\r\n * Compress whitespace while protecting code blocks and inline code\r\n */\r\nexport function compressWhitespace(input: string, protectCode: boolean = true): WhitespaceCompressionResult {\r\n  if (!protectCode) {\r\n    // Simple compression: remove excessive whitespace\r\n    const compressed = input\r\n      .replace(/\\n{3,}/g, \"\\n\\n\")  // Max 2 consecutive newlines\r\n      .replace(/[ \\t]{2,}/g, \" \")   // Max 1 space/tab\r\n      .replace(/[ \\t]+\\n/g, \"\\n\")  // Remove trailing spaces\r\n      .replace(/\\n[ \\t]+/g, \"\\n\");  // Remove leading spaces after newline\r\n    \r\n    return {\r\n      output: compressed,\r\n      compressed: compressed !== input\r\n    };\r\n  }\r\n  \r\n  // Protect code blocks\r\n  const lines = input.split(\"\\n\");\r\n  const result: string[] = [];\r\n  let inFence = false;\r\n  let fenceStart = -1;\r\n  \r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i];\r\n    const trimmed = line.trim();\r\n    \r\n    if (trimmed.startsWith(\"```\")) {\r\n      if (!inFence) {\r\n        // Starting a code block - compress everything before it\r\n        if (result.length > 0) {\r\n          const last = result[result.length - 1];\r\n          result[result.length - 1] = compressLineWhitespace(last);\r\n        }\r\n        fenceStart = result.length;\r\n      }\r\n      inFence = !inFence;\r\n      result.push(line);\r\n      continue;\r\n    }\r\n    \r\n    if (inFence) {\r\n      // Inside code block - preserve exactly\r\n      result.push(line);\r\n      continue;\r\n    }\r\n    \r\n    // Regular text - compress whitespace\r\n    const compressed = compressLineWhitespace(line);\r\n    \r\n    // Protect inline code: `code`\r\n    const protectedLine = protectInlineCode(compressed);\r\n    result.push(protectedLine);\r\n  }\r\n  \r\n  // Compress multiple consecutive newlines (but preserve code blocks)\r\n  const final: string[] = [];\r\n  let lastWasEmpty = false;\r\n  \r\n  for (let i = 0; i < result.length; i++) {\r\n    const line = result[i];\r\n    const isEmpty = line.trim().length === 0;\r\n    \r\n    if (isEmpty && lastWasEmpty) {\r\n      continue; // Skip consecutive empty lines\r\n    }\r\n    \r\n    final.push(line);\r\n    lastWasEmpty = isEmpty;\r\n  }\r\n  \r\n  const output = final.join(\"\\n\");\r\n  return {\r\n    output,\r\n    compressed: output !== input\r\n  };\r\n}\r\n\r\nfunction compressLineWhitespace(line: string): string {\r\n  return line\r\n    .replace(/[ \\t]{2,}/g, \" \")  // Multiple spaces/tabs -> single space\r\n    .replace(/^[ \\t]+/, \"\")      // Remove leading whitespace\r\n    .replace(/[ \\t]+$/, \"\");     // Remove trailing whitespace\r\n}\r\n\r\nfunction protectInlineCode(line: string): string {\r\n  // Split by inline code markers\r\n  const parts = line.split(/(`[^`]*`)/g);\r\n  const result: string[] = [];\r\n  \r\n  for (let i = 0; i < parts.length; i++) {\r\n    const part = parts[i];\r\n    if (part.startsWith(\"`\") && part.endsWith(\"`\")) {\r\n      // Inline code - preserve exactly\r\n      result.push(part);\r\n    } else {\r\n      // Regular text - compress\r\n      result.push(compressLineWhitespace(part));\r\n    }\r\n  }\r\n  \r\n  return result.join(\"\");\r\n}\r\n\r\n","/**\r\n * Duplicate Detection and Removal\r\n * \r\n * Identifies and removes duplicate sentences and paragraphs while preserving structure.\r\n * Useful for verbose text with repeated explanations.\r\n */\r\n\r\nexport interface DuplicateDetectionResult {\r\n  output: string;\r\n  duplicatesRemoved: number;\r\n}\r\n\r\n/**\r\n * Remove duplicate sentences while preserving document structure\r\n */\r\nexport function removeDuplicateSentences(input: string): DuplicateDetectionResult {\r\n  // Split into paragraphs first\r\n  const paragraphs = input.split(/\\n\\s*\\n/);\r\n  const seenSentences = new Set<string>();\r\n  const uniqueParagraphs: string[] = [];\r\n  let duplicatesRemoved = 0;\r\n  \r\n  for (const paragraph of paragraphs) {\r\n    // Split paragraph into sentences\r\n    const sentences = paragraph.split(/([.!?]+[\\s\\n])/);\r\n    const uniqueSentences: string[] = [];\r\n    \r\n    for (let i = 0; i < sentences.length; i += 2) {\r\n      const sentence = sentences[i];\r\n      const punctuation = sentences[i + 1] || \"\";\r\n      \r\n      if (!sentence || sentence.trim().length === 0) {\r\n        if (punctuation) uniqueSentences.push(punctuation);\r\n        continue;\r\n      }\r\n      \r\n      // Normalize sentence for comparison\r\n      const normalized = normalizeSentence(sentence);\r\n      \r\n      // Only keep if meaningful (length > 10 chars) and not seen before\r\n      if (normalized.length > 10 && !seenSentences.has(normalized)) {\r\n        seenSentences.add(normalized);\r\n        uniqueSentences.push(sentence + punctuation);\r\n      } else if (normalized.length > 10) {\r\n        duplicatesRemoved++;\r\n      }\r\n    }\r\n    \r\n    const uniqueParagraph = uniqueSentences.join(\"\");\r\n    if (uniqueParagraph.trim().length > 0) {\r\n      uniqueParagraphs.push(uniqueParagraph);\r\n    }\r\n  }\r\n  \r\n  return {\r\n    output: uniqueParagraphs.join(\"\\n\\n\"),\r\n    duplicatesRemoved\r\n  };\r\n}\r\n\r\n/**\r\n * Remove duplicate paragraphs\r\n */\r\nexport function removeDuplicateParagraphs(input: string): DuplicateDetectionResult {\r\n  const paragraphs = input.split(/\\n\\s*\\n/);\r\n  const seen = new Set<string>();\r\n  const unique: string[] = [];\r\n  let duplicatesRemoved = 0;\r\n  \r\n  for (const paragraph of paragraphs) {\r\n    const normalized = normalizeParagraph(paragraph);\r\n    \r\n    if (normalized.length > 20 && !seen.has(normalized)) {\r\n      seen.add(normalized);\r\n      unique.push(paragraph);\r\n    } else if (normalized.length > 20) {\r\n      duplicatesRemoved++;\r\n    } else {\r\n      // Keep short paragraphs (might be headers, lists, etc.)\r\n      unique.push(paragraph);\r\n    }\r\n  }\r\n  \r\n  return {\r\n    output: unique.join(\"\\n\\n\"),\r\n    duplicatesRemoved\r\n  };\r\n}\r\n\r\n/**\r\n * Remove both duplicate sentences and paragraphs\r\n */\r\nexport function removeDuplicates(input: string): DuplicateDetectionResult {\r\n  // First remove duplicate paragraphs\r\n  const paragraphResult = removeDuplicateParagraphs(input);\r\n  \r\n  // Then remove duplicate sentences within remaining paragraphs\r\n  const sentenceResult = removeDuplicateSentences(paragraphResult.output);\r\n  \r\n  return {\r\n    output: sentenceResult.output,\r\n    duplicatesRemoved: paragraphResult.duplicatesRemoved + sentenceResult.duplicatesRemoved\r\n  };\r\n}\r\n\r\nfunction normalizeSentence(sentence: string): string {\r\n  return sentence\r\n    .toLowerCase()\r\n    .trim()\r\n    .replace(/[^\\w\\s]/g, \"\")  // Remove punctuation\r\n    .replace(/\\s+/g, \" \");   // Normalize whitespace\r\n}\r\n\r\nfunction normalizeParagraph(paragraph: string): string {\r\n  return paragraph\r\n    .toLowerCase()\r\n    .trim()\r\n    .replace(/\\s+/g, \" \")   // Normalize whitespace\r\n    .replace(/\\n+/g, \" \");  // Remove newlines\r\n}\r\n\r\n","/**\r\n * Content Type Detection\r\n * \r\n * Detects the type of content to apply appropriate optimization strategies.\r\n */\r\n\r\nexport type ContentType = \"code\" | \"prose\" | \"log\" | \"json\" | \"documentation\" | \"mixed\";\r\n\r\nexport interface ContentTypeDetectionResult {\r\n  type: ContentType;\r\n  confidence: number;\r\n  features: {\r\n    codePercent: number;\r\n    prosePercent: number;\r\n    jsonPercent: number;\r\n    logPatterns: number;\r\n    docPatterns: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Detect content type based on patterns and structure\r\n */\r\nexport function detectContentType(input: string): ContentTypeDetectionResult {\r\n  const features = analyzeContentFeatures(input);\r\n  \r\n  // Calculate percentages\r\n  const total = features.codeChars + features.proseChars + features.jsonChars;\r\n  const codePercent = total > 0 ? features.codeChars / total : 0;\r\n  const prosePercent = total > 0 ? features.proseChars / total : 0;\r\n  const jsonPercent = total > 0 ? features.jsonChars / total : 0;\r\n  \r\n  // Determine type\r\n  let type: ContentType = \"mixed\";\r\n  let confidence = 0.5;\r\n  \r\n  if (jsonPercent > 0.8) {\r\n    type = \"json\";\r\n    confidence = 0.9;\r\n  } else if (features.logPatterns > 5) {\r\n    type = \"log\";\r\n    confidence = Math.min(0.9, 0.5 + features.logPatterns / 20);\r\n  } else if (codePercent > 0.6) {\r\n    type = \"code\";\r\n    confidence = Math.min(0.9, 0.5 + codePercent);\r\n  } else if (features.docPatterns > 3 && prosePercent > 0.7) {\r\n    type = \"documentation\";\r\n    confidence = Math.min(0.85, 0.5 + features.docPatterns / 10);\r\n  } else if (prosePercent > 0.7) {\r\n    type = \"prose\";\r\n    confidence = Math.min(0.8, 0.5 + prosePercent);\r\n  }\r\n  \r\n  return {\r\n    type,\r\n    confidence,\r\n    features: {\r\n      codePercent,\r\n      prosePercent,\r\n      jsonPercent,\r\n      logPatterns: features.logPatterns,\r\n      docPatterns: features.docPatterns\r\n    }\r\n  };\r\n}\r\n\r\nfunction analyzeContentFeatures(input: string): {\r\n  codeChars: number;\r\n  proseChars: number;\r\n  jsonChars: number;\r\n  logPatterns: number;\r\n  docPatterns: number;\r\n} {\r\n  let codeChars = 0;\r\n  let proseChars = 0;\r\n  let jsonChars = 0;\r\n  let logPatterns = 0;\r\n  let docPatterns = 0;\r\n  \r\n  // Check for JSON\r\n  const trimmed = input.trim();\r\n  if ((trimmed.startsWith(\"{\") || trimmed.startsWith(\"[\")) && trimmed.endsWith(\"}\") || trimmed.endsWith(\"]\")) {\r\n    try {\r\n      JSON.parse(trimmed);\r\n      jsonChars = input.length;\r\n      return { codeChars: 0, proseChars: 0, jsonChars, logPatterns: 0, docPatterns: 0 };\r\n    } catch {\r\n      // Not valid JSON\r\n    }\r\n  }\r\n  \r\n  // Log patterns (timestamps, log levels, etc.)\r\n  logPatterns += (input.match(/\\d{4}-\\d{2}-\\d{2}[\\sT]\\d{2}:\\d{2}:\\d{2}/g) || []).length;\r\n  logPatterns += (input.match(/\\[(ERROR|WARN|INFO|DEBUG|TRACE)\\]/gi) || []).length;\r\n  logPatterns += (input.match(/ERROR|WARNING|INFO|DEBUG/gi) || []).length;\r\n  \r\n  // Documentation patterns\r\n  docPatterns += (input.match(/^#{1,6}\\s+/gm) || []).length; // Markdown headers\r\n  docPatterns += (input.match(/```[\\s\\S]*?```/g) || []).length; // Code blocks\r\n  docPatterns += (input.match(/^[\\s]*[-*+]\\s+/gm) || []).length; // Lists\r\n  docPatterns += (input.match(/\\[.*?\\]\\(.*?\\)/g) || []).length; // Links\r\n  \r\n  // Analyze code vs prose\r\n  const lines = input.split(\"\\n\");\r\n  let inCodeBlock = false;\r\n  \r\n  for (const line of lines) {\r\n    if (line.trim().startsWith(\"```\")) {\r\n      inCodeBlock = !inCodeBlock;\r\n      if (inCodeBlock) codeChars += line.length;\r\n      continue;\r\n    }\r\n    \r\n    if (inCodeBlock) {\r\n      codeChars += line.length;\r\n      continue;\r\n    }\r\n    \r\n    // Check for code patterns\r\n    const codeIndicators = (line.match(/[{}();=<>[\\]]/g) || []).length;\r\n    const wordCount = (line.match(/\\b\\w+\\b/g) || []).length;\r\n    \r\n    if (codeIndicators > wordCount * 0.3) {\r\n      codeChars += line.length;\r\n    } else {\r\n      proseChars += line.length;\r\n    }\r\n  }\r\n  \r\n  return {\r\n    codeChars,\r\n    proseChars,\r\n    jsonChars,\r\n    logPatterns,\r\n    docPatterns\r\n  };\r\n}\r\n\r\n","/**\r\n * Long Content Summarization\r\n * \r\n * Summarizes very long content by extracting key information while removing redundancy.\r\n * Used when content exceeds token limits.\r\n */\r\n\r\nimport { estimateTokensHeuristic } from \"../estimators/heuristic.js\";\r\n\r\nexport interface SummarizationResult {\r\n  output: string;\r\n  originalTokens: number;\r\n  summarizedTokens: number;\r\n  compressionRatio: number;\r\n}\r\n\r\nexport interface SummarizationOptions {\r\n  maxTokens?: number;\r\n  preserveStructure?: boolean;\r\n  keepFirst?: boolean;\r\n  keepLast?: boolean;\r\n  minSentenceLength?: number;\r\n}\r\n\r\n/**\r\n * Summarize long content by extracting key sentences\r\n */\r\nexport function summarizeLongContent(\r\n  input: string,\r\n  options: SummarizationOptions = {}\r\n): SummarizationResult {\r\n  const {\r\n    maxTokens = 5000,\r\n    preserveStructure = true,\r\n    keepFirst = true,\r\n    keepLast = true,\r\n    minSentenceLength = 20\r\n  } = options;\r\n  \r\n  const originalTokens = estimateTokensHeuristic(input).tokens;\r\n  \r\n  // If already under limit, return as-is\r\n  if (originalTokens <= maxTokens) {\r\n    return {\r\n      output: input,\r\n      originalTokens,\r\n      summarizedTokens: originalTokens,\r\n      compressionRatio: 1.0\r\n    };\r\n  }\r\n  \r\n  // Split into paragraphs\r\n  const paragraphs = input.split(/\\n\\s*\\n/);\r\n  const summarized: string[] = [];\r\n  \r\n  // Keep first paragraph if requested\r\n  if (keepFirst && paragraphs.length > 0) {\r\n    summarized.push(paragraphs[0]);\r\n  }\r\n  \r\n  // Process middle paragraphs\r\n  const middleParagraphs = keepFirst && keepLast && paragraphs.length > 2\r\n    ? paragraphs.slice(1, -1)\r\n    : keepFirst\r\n    ? paragraphs.slice(1)\r\n    : keepLast && paragraphs.length > 1\r\n    ? paragraphs.slice(0, -1)\r\n    : paragraphs;\r\n  \r\n  for (const paragraph of middleParagraphs) {\r\n    const summary = summarizeParagraph(paragraph, minSentenceLength);\r\n    if (summary.trim().length > 0) {\r\n      summarized.push(summary);\r\n    }\r\n  }\r\n  \r\n  // Keep last paragraph if requested\r\n  if (keepLast && paragraphs.length > 1) {\r\n    const lastIdx = keepFirst ? paragraphs.length - 1 : paragraphs.length - 1;\r\n    summarized.push(paragraphs[lastIdx]);\r\n  }\r\n  \r\n  let output = preserveStructure\r\n    ? summarized.join(\"\\n\\n\")\r\n    : summarized.join(\" \");\r\n  \r\n  // If still too long, apply more aggressive compression\r\n  let currentTokens = estimateTokensHeuristic(output).tokens;\r\n  if (currentTokens > maxTokens) {\r\n    output = aggressiveCompress(output, maxTokens);\r\n  }\r\n  \r\n  const summarizedTokens = estimateTokensHeuristic(output).tokens;\r\n  \r\n  return {\r\n    output,\r\n    originalTokens,\r\n    summarizedTokens,\r\n    compressionRatio: summarizedTokens / originalTokens\r\n  };\r\n}\r\n\r\nfunction summarizeParagraph(paragraph: string, minLength: number): string {\r\n  // Split into sentences\r\n  const sentences = paragraph.split(/([.!?]+[\\s\\n])/);\r\n  const keySentences: string[] = [];\r\n  \r\n  for (let i = 0; i < sentences.length; i += 2) {\r\n    const sentence = sentences[i];\r\n    const punctuation = sentences[i + 1] || \"\";\r\n    \r\n    if (!sentence || sentence.trim().length < minLength) {\r\n      continue;\r\n    }\r\n    \r\n    // Score sentence importance\r\n    const score = scoreSentence(sentence);\r\n    \r\n    // Keep high-scoring sentences\r\n    if (score > 0.3) {\r\n      keySentences.push(sentence + punctuation);\r\n    }\r\n  }\r\n  \r\n  // If no key sentences found, return first and last\r\n  if (keySentences.length === 0 && sentences.length >= 2) {\r\n    const first = sentences[0];\r\n    const last = sentences[sentences.length - 2];\r\n    if (first && last) {\r\n      return first + (sentences[1] || \"\") + \" ... \" + last + (sentences[sentences.length - 1] || \"\");\r\n    }\r\n  }\r\n  \r\n  return keySentences.join(\" \");\r\n}\r\n\r\nfunction scoreSentence(sentence: string): number {\r\n  let score = 0;\r\n  const lower = sentence.toLowerCase();\r\n  \r\n  // Keywords that indicate importance\r\n  const importantKeywords = [\r\n    \"important\", \"essential\", \"critical\", \"key\", \"main\", \"primary\",\r\n    \"however\", \"therefore\", \"consequently\", \"thus\", \"moreover\",\r\n    \"example\", \"note\", \"warning\", \"error\", \"result\", \"conclusion\"\r\n  ];\r\n  \r\n  for (const keyword of importantKeywords) {\r\n    if (lower.includes(keyword)) {\r\n      score += 0.1;\r\n    }\r\n  }\r\n  \r\n  // Longer sentences often contain more information\r\n  score += Math.min(0.2, sentence.length / 200);\r\n  \r\n  // Sentences with numbers or specific data\r\n  if (/\\d+/.test(sentence)) {\r\n    score += 0.1;\r\n  }\r\n  \r\n  // Sentences starting with capital letters (likely proper nouns or important concepts)\r\n  if (/^[A-Z]/.test(sentence.trim())) {\r\n    score += 0.05;\r\n  }\r\n  \r\n  return Math.min(1.0, score);\r\n}\r\n\r\nfunction aggressiveCompress(text: string, maxTokens: number): string {\r\n  // Remove all filler words aggressively\r\n  const compressed = text\r\n    .replace(/\\b(the|a|an|and|or|but|in|on|at|to|for|of|with|by)\\b/gi, \"\")\r\n    .replace(/\\s+/g, \" \")\r\n    .trim();\r\n  \r\n  const tokens = estimateTokensHeuristic(compressed).tokens;\r\n  \r\n  if (tokens <= maxTokens) {\r\n    return compressed;\r\n  }\r\n  \r\n  // If still too long, truncate and add ellipsis\r\n  const ratio = maxTokens / tokens;\r\n  const targetLength = Math.floor(text.length * ratio * 0.9); // 90% to be safe\r\n  return text.substring(0, targetLength) + \"...\";\r\n}\r\n\r\n","/**\r\n * Context-Specific Optimizers\r\n * \r\n * Specialized optimizers for different content types:\r\n * - Log optimization\r\n * - Documentation optimization\r\n * - Code comment optimization\r\n */\r\n\r\nexport interface ContextOptimizationResult {\r\n  output: string;\r\n  originalTokens: number;\r\n  optimizedTokens: number;\r\n  savingsPercent: number;\r\n}\r\n\r\n/**\r\n * Optimize log files by removing timestamps and compressing repeated patterns\r\n */\r\nexport function optimizeLogs(logText: string): ContextOptimizationResult {\r\n  const originalTokens = Math.ceil(logText.length / 4); // Simple heuristic\r\n  \r\n  let optimized = logText;\r\n  \r\n  // Remove timestamps (various formats)\r\n  optimized = optimized.replace(/\\d{4}-\\d{2}-\\d{2}[\\sT]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})?/g, \"\");\r\n  optimized = optimized.replace(/\\[\\d{4}-\\d{2}-\\d{2}[\\sT]\\d{2}:\\d{2}:\\d{2}\\]/g, \"\");\r\n  optimized = optimized.replace(/\\d{2}\\/\\d{2}\\/\\d{4}\\s+\\d{2}:\\d{2}:\\d{2}/g, \"\");\r\n  \r\n  // Remove log level prefixes if repeated\r\n  optimized = optimized.replace(/\\[(ERROR|WARN|INFO|DEBUG|TRACE)\\]\\s*/gi, \"\");\r\n  \r\n  // Compress repeated error messages\r\n  const lines = optimized.split(\"\\n\");\r\n  const seenMessages = new Map<string, number>();\r\n  const compressed: string[] = [];\r\n  \r\n  for (const line of lines) {\r\n    const normalized = line.toLowerCase().trim();\r\n    if (normalized.length > 10) {\r\n      const count = seenMessages.get(normalized) || 0;\r\n      seenMessages.set(normalized, count + 1);\r\n      \r\n      if (count === 0) {\r\n        compressed.push(line);\r\n      } else if (count === 1) {\r\n        compressed.push(`[Repeated ${count + 1}x] ${line}`);\r\n      } else {\r\n        // Update count in previous line\r\n        const lastIdx = compressed.length - 1;\r\n        if (compressed[lastIdx].startsWith(\"[Repeated\")) {\r\n          compressed[lastIdx] = `[Repeated ${count + 1}x] ${line}`;\r\n        }\r\n      }\r\n    } else {\r\n      compressed.push(line);\r\n    }\r\n  }\r\n  \r\n  optimized = compressed.join(\"\\n\");\r\n  \r\n  // Remove excessive whitespace\r\n  optimized = optimized.replace(/\\n{3,}/g, \"\\n\\n\");\r\n  \r\n  const optimizedTokens = Math.ceil(optimized.length / 4);\r\n  const savingsPercent = originalTokens > 0\r\n    ? ((originalTokens - optimizedTokens) / originalTokens) * 100\r\n    : 0;\r\n  \r\n  return {\r\n    output: optimized,\r\n    originalTokens,\r\n    optimizedTokens,\r\n    savingsPercent: Math.round(savingsPercent * 100) / 100\r\n  };\r\n}\r\n\r\n/**\r\n * Optimize documentation by removing redundant explanations\r\n */\r\nexport function optimizeDocumentation(docText: string): ContextOptimizationResult {\r\n  const originalTokens = Math.ceil(docText.length / 4);\r\n  \r\n  let optimized = docText;\r\n  \r\n  // Remove \"As mentioned above/below\" references\r\n  optimized = optimized.replace(/\\bas mentioned (above|below|earlier|previously)\\b/gi, \"\");\r\n  optimized = optimized.replace(/\\bas (discussed|stated|noted) (above|below|earlier)\\b/gi, \"\");\r\n  \r\n  // Remove redundant \"Note:\" sections if they're obvious\r\n  optimized = optimized.replace(/Note:\\s*(It is important to|Remember that|Keep in mind that)/gi, \"Note:\");\r\n  \r\n  // Compress repeated examples\r\n  optimized = optimized.replace(/Example \\d+:\\s*/gi, \"Example: \");\r\n  \r\n  // Remove excessive \"See also\" references if many\r\n  const seeAlsoMatches = optimized.match(/See (also|above|below)/gi);\r\n  if (seeAlsoMatches && seeAlsoMatches.length > 3) {\r\n    optimized = optimized.replace(/See (also|above|below)[^.]*\\./gi, \"\");\r\n  }\r\n  \r\n  // Compress whitespace but preserve structure\r\n  optimized = optimized.replace(/\\n{4,}/g, \"\\n\\n\\n\");\r\n  \r\n  const optimizedTokens = Math.ceil(optimized.length / 4);\r\n  const savingsPercent = originalTokens > 0\r\n    ? ((originalTokens - optimizedTokens) / originalTokens) * 100\r\n    : 0;\r\n  \r\n  return {\r\n    output: optimized,\r\n    originalTokens,\r\n    optimizedTokens,\r\n    savingsPercent: Math.round(savingsPercent * 100) / 100\r\n  };\r\n}\r\n\r\n/**\r\n * Optimize code comments by removing obvious comments\r\n */\r\nexport function optimizeCodeComments(codeText: string): ContextOptimizationResult {\r\n  const originalTokens = Math.ceil(codeText.length / 4);\r\n  \r\n  let optimized = codeText;\r\n  const lines = optimized.split(\"\\n\");\r\n  const result: string[] = [];\r\n  \r\n  for (const line of lines) {\r\n    // Check if line is a comment\r\n    const trimmed = line.trim();\r\n    const isComment = trimmed.startsWith(\"//\") || trimmed.startsWith(\"/*\") || trimmed.startsWith(\"*\");\r\n    \r\n    if (!isComment) {\r\n      result.push(line);\r\n      continue;\r\n    }\r\n    \r\n    // Remove obvious comments\r\n    const commentText = trimmed.replace(/^\\/\\/\\s*|\\/\\*\\s*|\\*\\s*|\\*\\/\\s*$/g, \"\").toLowerCase();\r\n    \r\n    // Patterns that indicate obvious/redundant comments\r\n    const obviousPatterns = [\r\n      /^(set|get|assign|return|create|initialize|define|declare)\\s+\\w+/i,\r\n      /^(this|the|a|an)\\s+\\w+\\s+(is|does|returns|sets|gets)/i,\r\n      /^(variable|function|method|class|object)\\s+\\w+/i,\r\n      /^\\/\\/\\s*$/, // Empty comment\r\n    ];\r\n    \r\n    const isObvious = obviousPatterns.some(pattern => pattern.test(commentText));\r\n    \r\n    if (!isObvious || commentText.length > 50) {\r\n      // Keep non-obvious or detailed comments\r\n      result.push(line);\r\n    }\r\n    // Otherwise, remove the comment\r\n  }\r\n  \r\n  optimized = result.join(\"\\n\");\r\n  \r\n  // Remove excessive blank lines\r\n  optimized = optimized.replace(/\\n{3,}/g, \"\\n\\n\");\r\n  \r\n  const optimizedTokens = Math.ceil(optimized.length / 4);\r\n  const savingsPercent = originalTokens > 0\r\n    ? ((originalTokens - optimizedTokens) / originalTokens) * 100\r\n    : 0;\r\n  \r\n  return {\r\n    output: optimized,\r\n    originalTokens,\r\n    optimizedTokens,\r\n    savingsPercent: Math.round(savingsPercent * 100) / 100\r\n  };\r\n}\r\n\r\n","/**\r\n * Performance Cache\r\n * \r\n * LRU cache for optimization results to avoid redundant processing.\r\n */\r\n\r\ninterface CacheEntry {\r\n  output: string;\r\n  tokens: number;\r\n  timestamp: number;\r\n}\r\n\r\nclass LRUCache<K, V> {\r\n  private cache: Map<K, V>;\r\n  private maxSize: number;\r\n\r\n  constructor(maxSize: number = 1000) {\r\n    this.cache = new Map();\r\n    this.maxSize = maxSize;\r\n  }\r\n\r\n  get(key: K): V | undefined {\r\n    if (!this.cache.has(key)) {\r\n      return undefined;\r\n    }\r\n    \r\n    // Move to end (most recently used)\r\n    const value = this.cache.get(key)!;\r\n    this.cache.delete(key);\r\n    this.cache.set(key, value);\r\n    \r\n    return value;\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.cache.delete(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.cache.has(key);\r\n  }\r\n\r\n  set(key: K, value: V): void {\r\n    if (this.cache.has(key)) {\r\n      // Update existing\r\n      this.cache.delete(key);\r\n    } else if (this.cache.size >= this.maxSize) {\r\n      // Remove least recently used (first item)\r\n      const firstKey = this.cache.keys().next().value;\r\n      if (firstKey !== undefined) {\r\n        this.cache.delete(firstKey);\r\n      }\r\n    }\r\n    \r\n    this.cache.set(key, value);\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n}\r\n\r\n// Global cache instance\r\nconst optimizationCache = new LRUCache<string, CacheEntry>(1000);\r\nconst CACHE_TTL = 3600000; // 1 hour\r\n\r\n/**\r\n * Get cached optimization result\r\n */\r\nexport function getCachedResult(input: string): CacheEntry | null {\r\n  const cached = optimizationCache.get(input);\r\n  if (!cached) {\r\n    return null;\r\n  }\r\n  \r\n  // Check if cache entry is still valid\r\n  const age = Date.now() - cached.timestamp;\r\n  if (age > CACHE_TTL) {\r\n    optimizationCache.delete(input);\r\n    return null;\r\n  }\r\n  \r\n  return cached;\r\n}\r\n\r\n/**\r\n * Cache optimization result\r\n */\r\nexport function cacheResult(input: string, output: string, tokens: number): void {\r\n  optimizationCache.set(input, {\r\n    output,\r\n    tokens,\r\n    timestamp: Date.now()\r\n  });\r\n}\r\n\r\n/**\r\n * Clear the cache\r\n */\r\nexport function clearCache(): void {\r\n  optimizationCache.clear();\r\n}\r\n\r\n/**\r\n * Get cache statistics\r\n */\r\nexport function getCacheStats(): { size: number; maxSize: number } {\r\n  return {\r\n    size: optimizationCache.size(),\r\n    maxSize: 1000\r\n  };\r\n}\r\n\r\n/**\r\n * Check if content has optimization potential (quick heuristic)\r\n * Used for early exit to avoid unnecessary processing\r\n */\r\nexport function hasOptimizationPotential(text: string): boolean {\r\n  // Check for common filler words\r\n  const fillerPattern = /basically|actually|simply|in fact|obviously|literally|you know|I mean/i;\r\n  if (fillerPattern.test(text)) {\r\n    return true;\r\n  }\r\n  \r\n  // Check for verbose phrases\r\n  const verbosePattern = /in order to|due to the fact that|at this point in time|for the purpose of/i;\r\n  if (verbosePattern.test(text)) {\r\n    return true;\r\n  }\r\n  \r\n  // Check for excessive whitespace\r\n  if (/\\n{3,}/.test(text) || /[ \\t]{3,}/.test(text)) {\r\n    return true;\r\n  }\r\n  \r\n  // Check for duplicate sentences (simple heuristic)\r\n  const sentences = text.split(/[.!?]+\\s+/);\r\n  const seen = new Set<string>();\r\n  for (const sentence of sentences) {\r\n    const normalized = sentence.toLowerCase().trim();\r\n    if (normalized.length > 20 && seen.has(normalized)) {\r\n      return true;\r\n    }\r\n    seen.add(normalized);\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\n","/**\r\n * Advanced Optimization Engine\r\n * \r\n * Combines all optimization strategies intelligently based on content type and target savings.\r\n * Provides token-aware optimization that stops when target is reached.\r\n */\r\n\r\nimport { stripFillers } from \"../strip-fillers/engine.js\";\r\nimport { Preset } from \"../strip-fillers/presets.js\";\r\nimport { applySemanticCompression } from \"./semantic-compression.js\";\r\nimport { compressWhitespace } from \"./whitespace-compression.js\";\r\nimport { removeDuplicates } from \"./duplicate-detection.js\";\r\nimport { detectContentType, ContentType } from \"./content-type-detection.js\";\r\nimport { summarizeLongContent, SummarizationOptions } from \"./summarization.js\";\r\nimport { optimizeLogs, optimizeDocumentation, optimizeCodeComments } from \"./context-specific.js\";\r\nimport { estimateTokensHeuristic } from \"../estimators/heuristic.js\";\r\nimport { getCachedResult, cacheResult, hasOptimizationPotential } from \"./cache.js\";\r\n\r\nexport interface AdvancedOptimizationOptions {\r\n  targetSavingsPercent?: number;\r\n  maxTokens?: number;\r\n  preset?: Preset;\r\n  enableSemanticCompression?: boolean;\r\n  enableWhitespaceCompression?: boolean;\r\n  enableDuplicateRemoval?: boolean;\r\n  enableSummarization?: boolean;\r\n  enableContextOptimization?: boolean;\r\n  contentType?: ContentType; // Auto-detect if not provided\r\n}\r\n\r\nexport interface AdvancedOptimizationResult {\r\n  output: string;\r\n  originalTokens: number;\r\n  optimizedTokens: number;\r\n  saved: number;\r\n  savingsPercent: number;\r\n  strategies: string[];\r\n  contentType: ContentType;\r\n}\r\n\r\n/**\r\n * Optimize content using all available strategies\r\n */\r\nexport function optimizeAdvanced(\r\n  input: string,\r\n  options: AdvancedOptimizationOptions = {}\r\n): AdvancedOptimizationResult {\r\n  // Check cache first\r\n  const cacheKey = JSON.stringify({ input, options });\r\n  const cached = getCachedResult(cacheKey);\r\n  if (cached) {\r\n    return {\r\n      output: cached.output,\r\n      originalTokens: estimateTokensHeuristic(input).tokens,\r\n      optimizedTokens: cached.tokens,\r\n      saved: estimateTokensHeuristic(input).tokens - cached.tokens,\r\n      savingsPercent: estimateTokensHeuristic(input).tokens > 0\r\n        ? ((estimateTokensHeuristic(input).tokens - cached.tokens) / estimateTokensHeuristic(input).tokens) * 100\r\n        : 0,\r\n      strategies: [\"cached\"],\r\n      contentType: detectContentType(input).type\r\n    };\r\n  }\r\n  \r\n  // Quick check: skip if no optimization potential\r\n  if (!hasOptimizationPotential(input)) {\r\n    const tokens = estimateTokensHeuristic(input).tokens;\r\n    cacheResult(cacheKey, input, tokens);\r\n    return {\r\n      output: input,\r\n      originalTokens: tokens,\r\n      optimizedTokens: tokens,\r\n      saved: 0,\r\n      savingsPercent: 0,\r\n      strategies: [],\r\n      contentType: detectContentType(input).type\r\n    };\r\n  }\r\n  const {\r\n    targetSavingsPercent,\r\n    maxTokens,\r\n    preset = \"standard\",\r\n    enableSemanticCompression = true,\r\n    enableWhitespaceCompression = true,\r\n    enableDuplicateRemoval = true,\r\n    enableSummarization = true,\r\n    enableContextOptimization = true,\r\n    contentType: providedContentType\r\n  } = options;\r\n  \r\n  const originalTokens = estimateTokensHeuristic(input).tokens;\r\n  const targetTokens = targetSavingsPercent\r\n    ? Math.floor(originalTokens * (1 - targetSavingsPercent / 100))\r\n    : maxTokens || originalTokens;\r\n  \r\n  let result = input;\r\n  const strategies: string[] = [];\r\n  \r\n  // Detect content type if not provided\r\n  const detection = detectContentType(result);\r\n  const contentType = providedContentType || detection.type;\r\n  \r\n  // 1. Context-specific optimization (highest impact for specific types)\r\n  if (enableContextOptimization) {\r\n    let contextResult;\r\n    switch (contentType) {\r\n      case \"log\":\r\n        contextResult = optimizeLogs(result);\r\n        if (contextResult.savingsPercent > 5) {\r\n          result = contextResult.output;\r\n          strategies.push(\"log-optimization\");\r\n        }\r\n        break;\r\n      case \"documentation\":\r\n        contextResult = optimizeDocumentation(result);\r\n        if (contextResult.savingsPercent > 5) {\r\n          result = contextResult.output;\r\n          strategies.push(\"doc-optimization\");\r\n        }\r\n        break;\r\n      case \"code\":\r\n        contextResult = optimizeCodeComments(result);\r\n        if (contextResult.savingsPercent > 5) {\r\n          result = contextResult.output;\r\n          strategies.push(\"code-comment-optimization\");\r\n        }\r\n        break;\r\n    }\r\n    \r\n    // Early exit if target reached\r\n    const currentTokens = estimateTokensHeuristic(result).tokens;\r\n    if (currentTokens <= targetTokens) {\r\n      return {\r\n        output: result,\r\n        originalTokens,\r\n        optimizedTokens: currentTokens,\r\n        saved: originalTokens - currentTokens,\r\n        savingsPercent: originalTokens > 0 ? ((originalTokens - currentTokens) / originalTokens) * 100 : 0,\r\n        strategies,\r\n        contentType\r\n      };\r\n    }\r\n  }\r\n  \r\n  // 2. Remove duplicates (high impact, low risk)\r\n  if (enableDuplicateRemoval) {\r\n    const duplicateResult = removeDuplicates(result);\r\n    if (duplicateResult.duplicatesRemoved > 0) {\r\n      result = duplicateResult.output;\r\n      strategies.push(\"duplicate-removal\");\r\n      \r\n      const currentTokens = estimateTokensHeuristic(result).tokens;\r\n      if (currentTokens <= targetTokens) {\r\n        return createResult(result, originalTokens, strategies, contentType);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 3. Semantic compression\r\n  if (enableSemanticCompression) {\r\n    const semanticResult = applySemanticCompression(result);\r\n    if (semanticResult.replacements > 0) {\r\n      result = semanticResult.output;\r\n      strategies.push(\"semantic-compression\");\r\n      \r\n      const currentTokens = estimateTokensHeuristic(result).tokens;\r\n      if (currentTokens <= targetTokens) {\r\n        return createResult(result, originalTokens, strategies, contentType);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 4. Strip fillers (gradually increase aggressiveness)\r\n  const presets: Preset[] = [\"conservative\", \"standard\", \"aggressive\", \"ultra\"];\r\n  let presetIndex = presets.indexOf(preset);\r\n  \r\n  for (let i = presetIndex; i < presets.length; i++) {\r\n    const stripResult = stripFillers(result, { preset: presets[i] });\r\n    if (stripResult.meta.changed) {\r\n      result = stripResult.output;\r\n      if (!strategies.includes(\"strip-fillers\")) {\r\n        strategies.push(`strip-fillers-${presets[i]}`);\r\n      } else {\r\n        // Update to more aggressive preset\r\n        const idx = strategies.findIndex(s => s.startsWith(\"strip-fillers\"));\r\n        strategies[idx] = `strip-fillers-${presets[i]}`;\r\n      }\r\n      \r\n      const currentTokens = estimateTokensHeuristic(result).tokens;\r\n      if (currentTokens <= targetTokens) {\r\n        return createResult(result, originalTokens, strategies, contentType);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 5. Whitespace compression\r\n  if (enableWhitespaceCompression) {\r\n    const whitespaceResult = compressWhitespace(result, true);\r\n    if (whitespaceResult.compressed) {\r\n      result = whitespaceResult.output;\r\n      strategies.push(\"whitespace-compression\");\r\n      \r\n      const currentTokens = estimateTokensHeuristic(result).tokens;\r\n      if (currentTokens <= targetTokens) {\r\n        return createResult(result, originalTokens, strategies, contentType);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 6. Summarization (last resort for very long content)\r\n  if (enableSummarization && originalTokens > 10000) {\r\n    const summaryResult = summarizeLongContent(result, {\r\n      maxTokens: targetTokens,\r\n      preserveStructure: true,\r\n      keepFirst: true,\r\n      keepLast: true\r\n    });\r\n    \r\n    if (summaryResult.compressionRatio < 1.0) {\r\n      result = summaryResult.output;\r\n      strategies.push(\"summarization\");\r\n    }\r\n  }\r\n  \r\n  const finalResult = createResult(result, originalTokens, strategies, contentType);\r\n  \r\n  // Cache the result\r\n  cacheResult(cacheKey, finalResult.output, finalResult.optimizedTokens);\r\n  \r\n  return finalResult;\r\n}\r\n\r\nfunction createResult(\r\n  output: string,\r\n  originalTokens: number,\r\n  strategies: string[],\r\n  contentType: ContentType\r\n): AdvancedOptimizationResult {\r\n  const optimizedTokens = estimateTokensHeuristic(output).tokens;\r\n  const saved = originalTokens - optimizedTokens;\r\n  const savingsPercent = originalTokens > 0\r\n    ? (saved / originalTokens) * 100\r\n    : 0;\r\n  \r\n  return {\r\n    output,\r\n    originalTokens,\r\n    optimizedTokens,\r\n    saved,\r\n    savingsPercent: Math.round(savingsPercent * 100) / 100,\r\n    strategies,\r\n    contentType\r\n  };\r\n}\r\n\r\n\r\n","#!/usr/bin/env node\r\nimport { readFileText, readStdinSync, writeFileText } from \"./utils/io.js\";\r\nimport { estimateTokensHeuristic } from \"./estimators/heuristic.js\";\r\nimport { jsonMinify } from \"./json-minify.js\";\r\nimport { unifiedDiff } from \"./diff.js\";\r\nimport { stripFillers } from \"./strip-fillers/engine.js\";\r\nimport { optimizeAdvanced, AdvancedOptimizationOptions } from \"./optimizers/advanced-engine.js\";\r\n\r\nfunction parseArgs(argv: string[]) {\r\n  const opts: Record<string, string | boolean> = {};\r\n  const args: string[] = [];\r\n  for (let i = 0; i < argv.length; i++) {\r\n    const a = argv[i];\r\n    if (a.startsWith(\"--\")) {\r\n      const [k, v] = a.slice(2).split(\"=\");\r\n      opts[k] = v ?? true;\r\n    } else if (a.startsWith(\"-\")) {\r\n      opts[a.slice(1)] = true;\r\n    } else {\r\n      args.push(a);\r\n    }\r\n  }\r\n  return { cmd: args.shift() || \"\", args, opts } as const;\r\n}\r\n\r\nfunction outOrStdout(text: string, out?: string) {\r\n  if (out && typeof out === \"string\") writeFileText(out, text);\r\n  else process.stdout.write(text);\r\n}\r\n\r\nexport async function main(argv: string[] = process.argv.slice(2)) {\r\n  const { cmd, args, opts } = parseArgs(argv);\r\n  if (opts.v || opts.version) {\r\n    const pkg = await import(\"../package.json\", { with: { type: \"json\" } } as any).catch(() => ({ default: { version: \"0.0.0\" } }));\r\n    console.log(pkg.default.version);\r\n    return 0;\r\n  }\r\n\r\n  try {\r\n    if (cmd === \"json-minify\") {\r\n      const input = args[0] ? readFileText(args[0]) : readStdinSync();\r\n      const res = jsonMinify(input, { keepEol: !!opts[\"keep-eol\"], maxBytes: undefined });\r\n      outOrStdout(res.output + \"\\n\", opts.out as string | undefined);\r\n      if (opts.report) {\r\n        const before = estimateTokensHeuristic(input);\r\n        const after = estimateTokensHeuristic(res.output);\r\n        console.error(JSON.stringify({ mode: \"json-minify\", before, after }));\r\n      }\r\n      return 0;\r\n    }\r\n    if (cmd === \"diff\") {\r\n      const before = args[0] ? readFileText(args[0]) : readStdinSync();\r\n      const after = args[1] ? readFileText(args[1]) : \"\";\r\n      const patch = unifiedDiff(\"before\", before, \"after\", after, { keepEol: !!opts[\"keep-eol\"] });\r\n      outOrStdout(patch, opts.out as string | undefined);\r\n      if (opts.report) {\r\n        const b = estimateTokensHeuristic(before, { diffHeuristicBump: true });\r\n        const a = estimateTokensHeuristic(after, { diffHeuristicBump: true });\r\n        console.error(JSON.stringify({ mode: \"diff\", before: b, after: a }));\r\n      }\r\n      return 0;\r\n    }\r\n    if (cmd === \"strip-fillers\") {\r\n      const input = args[0] ? readFileText(args[0]) : readStdinSync();\r\n      const preset = (opts.preset as string) || \"conservative\";\r\n      const res = stripFillers(input, { preset: preset as any, keepEol: !!opts[\"keep-eol\"] });\r\n      outOrStdout(res.output + \"\\n\", opts.out as string | undefined);\r\n      if (opts.report) {\r\n        const before = estimateTokensHeuristic(input);\r\n        const after = estimateTokensHeuristic(res.output);\r\n        console.error(JSON.stringify({ mode: \"strip-fillers\", before, after }));\r\n      }\r\n      return 0;\r\n    }\r\n    if (cmd === \"optimize\" || cmd === \"advanced\") {\r\n      const input = args[0] ? readFileText(args[0]) : readStdinSync();\r\n      const options: AdvancedOptimizationOptions = {\r\n        preset: (opts.preset as any) || \"standard\",\r\n        targetSavingsPercent: opts[\"target-savings\"] ? parseFloat(opts[\"target-savings\"] as string) : undefined,\r\n        maxTokens: opts[\"max-tokens\"] ? parseInt(opts[\"max-tokens\"] as string, 10) : undefined,\r\n        enableSemanticCompression: opts[\"no-semantic\"] !== true,\r\n        enableWhitespaceCompression: opts[\"no-whitespace\"] !== true,\r\n        enableDuplicateRemoval: opts[\"no-duplicates\"] !== true,\r\n        enableSummarization: opts[\"no-summarization\"] !== true,\r\n        enableContextOptimization: opts[\"no-context\"] !== true,\r\n      };\r\n      const res = optimizeAdvanced(input, options);\r\n      outOrStdout(res.output + \"\\n\", opts.out as string | undefined);\r\n      if (opts.report) {\r\n        console.error(JSON.stringify({\r\n          mode: \"advanced-optimization\",\r\n          before: { tokens: res.originalTokens },\r\n          after: { tokens: res.optimizedTokens },\r\n          saved: res.saved,\r\n          savingsPercent: res.savingsPercent,\r\n          strategies: res.strategies,\r\n          contentType: res.contentType\r\n        }));\r\n      }\r\n      return 0;\r\n    }\r\n    console.error(\"Usage: token-saver <json-minify|diff|strip-fillers|optimize> [args] [--report --model --keep-eol --out --preset --target-savings --max-tokens]\");\r\n    return 1;\r\n  } catch (e) {\r\n    const msg = (e as Error).message || String(e);\r\n    const code = (e as any)?.code === 2 ? 2 : 1;\r\n    console.error(msg);\r\n    return code;\r\n  }\r\n}\r\n\r\nif (import.meta.url === `file://${process.argv[1]}` || process.argv[1]?.endsWith(\"/bin/token-saver.js\")) {\r\n  // eslint-disable-next-line unicorn/prefer-top-level-await\r\n  main().then((code) => process.exit(code)).catch((err) => {\r\n    console.error(err?.message ?? String(err));\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\n"],"mappings":";AAAA,OAAO,QAAQ;AACf,OAAO,UAAU;AAEV,SAAS,gBAAwB;AACtC,QAAM,KAAK;AACX,MAAI;AACF,QAAI,GAAG,UAAU,EAAE,EAAE,OAAO,KAAK,GAAG,UAAU,EAAE,EAAE,OAAO,GAAG;AAC1D,aAAO,GAAG,aAAa,IAAI,MAAM;AAAA,IACnC;AAAA,EACF,QAAQ;AAAA,EAAC;AACT,SAAO;AACT;AAEO,SAAS,aAAa,GAAmB;AAC9C,SAAO,GAAG,aAAa,GAAG,MAAM;AAClC;AAEO,SAAS,cAAc,GAAW,MAAoB;AAC3D,QAAM,MAAM,KAAK,QAAQ,CAAC;AAC1B,KAAG,UAAU,KAAK,EAAE,WAAW,KAAK,CAAC;AACrC,KAAG,cAAc,GAAG,MAAM,MAAM;AAClC;;;ACrBA,IAAM,iBAAyC;AAAA,EAC7C,eAAe;AAAA,EACf,WAAW;AAAA,EACX,cAAc;AAAA,EACd,cAAc;AAAA,EACd,WAAW;AACb;AAOO,SAAS,wBAAwB,MAAc,OAAwB,CAAC,GAAG;AAChF,QAAM,QAAQ,KAAK,SAAS,eAAe,KAAK,KAAK,IAAI,KAAK,QAAQ;AACtE,QAAM,QAAQ,KAAK;AACnB,QAAM,QAAQ,eAAe,KAAK;AAClC,MAAI,SAAS,KAAK,KAAK,QAAQ,KAAK;AACpC,MAAI;AACJ,MAAI,KAAK,mBAAmB;AAC1B,aAAS,KAAK,KAAK,SAAS,IAAI;AAChC,WAAO;AAAA,EACT;AACA,SAAO,EAAE,OAAO,QAAQ,OAAO,KAAK;AACtC;;;ACtBO,SAAS,UAAU,MAAmB;AAC3C,QAAM,MAAM,KAAK,QAAQ,IAAI;AAC7B,MAAI,QAAQ,GAAI,QAAO,KAAK,QAAQ,IAAI,MAAM,KAAK,OAAO;AAC1D,SAAO,KAAK,MAAM,CAAC,MAAM,OAAO,SAAS;AAC3C;AAEO,SAAS,aAAa,MAAc,SAA8C;AACvF,MAAI,CAAC,KAAM,QAAO,EAAE,MAAM,KAAK,KAAK;AACpC,QAAM,WAAW,UAAU,IAAI;AAC/B,MAAI,QAAS,QAAO,EAAE,MAAM,KAAK,SAAS;AAC1C,QAAM,UAAU,KAAK,QAAQ,aAAa,IAAI;AAC9C,SAAO,EAAE,MAAM,SAAS,KAAK,KAAK;AACpC;;;ACdO,SAAS,aAAa,MAAsB;AACjD,SAAO,KAAK,UAAU,KAAK;AAC7B;;;ACWA,IAAM,cAAc,KAAK,OAAO;AAEzB,SAAS,WAAW,OAAe,OAA0B,CAAC,GAAoB;AACvF,QAAM,WAAW,KAAK,YAAY;AAClC,QAAM,EAAE,KAAK,IAAI,aAAa,aAAa,KAAK,GAAG,CAAC,CAAC,KAAK,OAAO;AACjE,MAAI,OAAO,WAAW,MAAM,MAAM,IAAI,UAAU;AAC9C,UAAM,MAAM,IAAI,MAAM,0BAA0B;AAEhD,QAAI,OAAO;AACX,UAAM;AAAA,EACR;AAEA,QAAM,UAAU,KAAK,KAAK;AAE1B,QAAM,WAAW,QAAQ,SAAS,IAAI;AAEtC,MAAI;AACF,QAAI,CAAC,UAAU;AACb,YAAM,SAAS,KAAK,MAAM,OAAO;AACjC,YAAM,MAAM,KAAK,UAAU,MAAM;AACjC,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,MAAM,EAAE,SAAS,QAAQ,SAAS,WAAW,EAAE,YAAY,GAAG,QAAQ,GAAG,MAAM,KAAK,EAAE;AAAA,MACxF;AAAA,IACF;AAEA,UAAM,QAAQ,KAAK,MAAM,IAAI;AAC7B,UAAM,MAAgB,CAAC;AACvB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAC,EAAE,KAAK;AAC3B,UAAI,SAAS,IAAI;AAAE,YAAI,KAAK,EAAE;AAAG;AAAA,MAAU;AAC3C,UAAI;AACF,cAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,YAAI,KAAK,KAAK,UAAU,MAAM,CAAC;AAAA,MACjC,SAAS,GAAG;AACV,cAAM,MAAO,EAAY,WAAW;AACpC,cAAM,MAAM,IAAI,MAAM,0BAA0B,IAAI,CAAC,KAAK,GAAG,EAAE;AAE/D,YAAI,OAAO;AACX,cAAM;AAAA,MACR;AAAA,IACF;AACA,UAAM,SAAS,IAAI,KAAK,IAAI;AAC5B,WAAO,EAAE,QAAQ,QAAQ,MAAM,EAAE,SAAS,WAAW,MAAM,WAAW,EAAE,YAAY,GAAG,QAAQ,GAAG,MAAM,KAAK,EAAE,EAAE;AAAA,EACnH,SAAS,GAAG;AACV,QAAK,GAAW,SAAS,EAAG,OAAM;AAClC,UAAM,UAAW,EAAY,WAAW;AACxC,UAAM,MAAM,IAAI,MAAM,iBAAiB,OAAO,EAAE;AAEhD,QAAI,OAAO;AACX,UAAM;AAAA,EACR;AACF;;;ACjEA,SAAS,2BAA2B;AAQ7B,SAAS,YAAY,YAAoB,QAAgB,WAAmB,OAAe,OAAoB,CAAC,GAAW;AAChI,QAAM,IAAI,aAAa,aAAa,MAAM,GAAG,CAAC,CAAC,KAAK,OAAO,EAAE;AAC7D,QAAM,IAAI,aAAa,aAAa,KAAK,GAAG,CAAC,CAAC,KAAK,OAAO,EAAE;AAC5D,QAAM,QAAQ,oBAAoB,UAAU,SAAS,GAAG,GAAG,QAAW,QAAW,EAAE,SAAS,EAAE,CAAC;AAE/F,SAAO,MACJ,QAAQ,YAAY,YAAY,EAChC,QAAQ,eAAe,WAAW;AACvC;;;ACZO,SAAS,kBAAkB,QAAyC;AACzE,QAAM,OAAgC;AAAA,IACpC,CAAC,qBAAqB,IAAI;AAAA,IAC1B,CAAC,8BAA8B,SAAS;AAAA,IACxC,CAAC,yCAAyC,EAAE;AAAA,IAC5C,CAAC,+BAA+B,EAAE;AAAA,IAClC,CAAC,mDAAmD,EAAE;AAAA,EACxD;AACA,QAAM,WAAoC;AAAA,IACxC,CAAC,wBAAwB,EAAE;AAAA,IAC3B,CAAC,uBAAuB,EAAE;AAAA,IAC1B,CAAC,qBAAqB,EAAE;AAAA,IACxB,CAAC,sBAAsB,EAAE;AAAA,IACzB,CAAC,8BAA8B,EAAE;AAAA,IACjC,CAAC,6BAA6B,EAAE;AAAA,IAChC,CAAC,4BAA4B,EAAE;AAAA,IAC/B,CAAC,gCAAgC,EAAE;AAAA,IACnC,CAAC,qCAAqC,EAAE;AAAA,IACxC,CAAC,oBAAoB,EAAE;AAAA,IACvB,CAAC,oBAAoB,EAAE;AAAA,EACzB;AACA,QAAM,aAAsC;AAAA,IAC1C,CAAC,wBAAwB,EAAE;AAAA,IAC3B,CAAC,wBAAwB,EAAE;AAAA,IAC3B,CAAC,4BAA4B,EAAE;AAAA,IAC/B,CAAC,2BAA2B,EAAE;AAAA,IAC9B,CAAC,iBAAiB,EAAE;AAAA,IACpB,CAAC,iBAAiB,EAAE;AAAA,EACtB;AACA,QAAM,QAAiC;AAAA,IACrC,CAAC,wBAAwB,EAAE;AAAA,IAC3B,CAAC,sBAAsB,EAAE;AAAA,IACzB,CAAC,4BAA4B,EAAE;AAAA,IAC/B,CAAC,qBAAqB,EAAE;AAAA,IACxB,CAAC,oBAAoB,EAAE;AAAA,IACvB,CAAC,kBAAkB,EAAE;AAAA,IACrB,CAAC,gBAAgB,EAAE;AAAA,IACnB,CAAC,iBAAiB,EAAE;AAAA,IACpB,CAAC,mBAAmB,EAAE;AAAA,IACtB,CAAC,qBAAqB,EAAE;AAAA,IACxB,CAAC,wBAAwB,QAAQ;AAAA,IACjC,CAAC,sCAAsC,EAAE;AAAA,IACzC,CAAC,sBAAsB,MAAM;AAAA,IAC7B,CAAC,2BAA2B,EAAE;AAAA,IAC9B,CAAC,0BAA0B,KAAK;AAAA,IAChC,CAAC,kBAAkB,QAAQ;AAAA,IAC3B,CAAC,uBAAuB,OAAO;AAAA,IAC/B,CAAC,2BAA2B,IAAI;AAAA,IAChC,CAAC,wBAAwB,OAAO;AAAA,IAChC,CAAC,qBAAqB,KAAK;AAAA,IAC3B,CAAC,wBAAwB,KAAK;AAAA,IAC9B,CAAC,2BAA2B,IAAI;AAAA,IAChC,CAAC,yBAAyB,KAAK;AAAA,IAC/B,CAAC,wBAAwB,OAAO;AAAA,IAChC,CAAC,mBAAmB,KAAK;AAAA,IACzB,CAAC,6BAA6B,SAAS;AAAA,IACvC,CAAC,+BAA+B,KAAK;AAAA,IACrC,CAAC,4BAA4B,MAAM;AAAA,IACnC,CAAC,6BAA6B,KAAK;AAAA,EACrC;AACA,MAAI,WAAW,eAAgB,QAAO;AACtC,MAAI,WAAW,WAAY,QAAO,KAAK,OAAO,QAAQ;AACtD,MAAI,WAAW,aAAc,QAAO,KAAK,OAAO,UAAU,UAAU;AACpE,SAAO,KAAK,OAAO,UAAU,YAAY,KAAK;AAChD;;;ACtDA,SAAS,aAAa,MAAuB;AAC3C,QAAM,IAAI,KAAK,KAAK;AACpB,MAAI,EAAE,EAAE,WAAW,GAAG,KAAK,EAAE,WAAW,GAAG,GAAI,QAAO;AACtD,MAAI;AAAE,SAAK,MAAM,CAAC;AAAG,WAAO;AAAA,EAAM,QAAQ;AAAE,WAAO;AAAA,EAAO;AAC5D;AAGO,SAAS,aAAa,OAAe,OAAqB,CAAC,GAAgB;AAChF,QAAM,EAAE,KAAK,IAAI,aAAa,aAAa,KAAK,GAAG,CAAC,CAAC,KAAK,OAAO;AACjE,MAAI,aAAa,IAAI,GAAG;AACtB,WAAO,EAAE,QAAQ,MAAM,MAAM,EAAE,SAAS,OAAO,WAAW,EAAE,YAAY,GAAG,QAAQ,GAAG,MAAM,KAAK,EAAE,EAAE;AAAA,EACvG;AACA,QAAM,SAAS,KAAK,UAAU;AAC9B,QAAM,WAAW,kBAAkB,MAAM;AAEzC,QAAM,QAAQ,KAAK,MAAM,IAAI;AAC7B,MAAI,UAAU;AACd,MAAI,aAAa;AACjB,MAAI,cAAc;AAClB,QAAM,MAAgB,CAAC;AAEvB,aAAW,QAAQ,OAAO;AACxB,QAAI,KAAK,KAAK,EAAE,WAAW,KAAK,GAAG;AACjC,gBAAU,CAAC;AACX,UAAI,QAAS;AACb,UAAI,KAAK,IAAI;AACb;AAAA,IACF;AACA,QAAI,SAAS;AAAE,UAAI,KAAK,IAAI;AAAG;AAAA,IAAU;AAGzC,UAAM,WAAqB,CAAC;AAC5B,UAAM,QAAQ,KAAK,MAAM,YAAY;AACrC,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,MAAM,MAAM,CAAC;AACnB,YAAM,WAAW,IAAI,WAAW,GAAG,KAAK,IAAI,SAAS,GAAG;AACxD,UAAI,UAAU;AAAE,iBAAS,KAAK,GAAG;AAAG;AAAe;AAAA,MAAU;AAC7D,UAAI,IAAI;AAER,YAAM,OAAO,IAAI,KAAK,MAAM,IAAI,CAAC,EAAE,WAAW,GAAG;AACjD,YAAM,QAAQ,IAAI,MAAM,SAAS,KAAK,MAAM,IAAI,CAAC,EAAE,WAAW,GAAG;AACjE,UAAI,EAAE,QAAQ,QAAQ;AACpB,mBAAW,CAAC,IAAI,GAAG,KAAK,UAAU;AAChC,cAAI,EAAE,QAAQ,IAAI,GAAG;AAAA,QACvB;AAAA,MACF;AACA,eAAS,KAAK,CAAC;AAAA,IACjB;AACA,QAAI,KAAK,SAAS,KAAK,EAAE,CAAC;AAAA,EAC5B;AAEA,QAAM,SAAS,IAAI,KAAK,IAAI;AAC5B,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,MAAM,EAAE,SAAS,WAAW,MAAM,WAAW,EAAE,YAAY,YAAY,QAAQ,aAAa,MAAM,MAAM,EAAE;AAAA,EAC5G;AACF;;;AC1DA,IAAM,uBAAgD;AAAA;AAAA,EAEpD,CAAC,gCAAgC,SAAS;AAAA,EAC1C,CAAC,6BAA6B,QAAQ;AAAA,EACtC,CAAC,qCAAqC,SAAS;AAAA,EAC/C,CAAC,8BAA8B,OAAO;AAAA,EACtC,CAAC,mBAAmB,IAAI;AAAA,EACxB,CAAC,iBAAiB,IAAI;AAAA,EACtB,CAAC,iBAAiB,IAAI;AAAA;AAAA,EAGtB,CAAC,6BAA6B,KAAK;AAAA,EACnC,CAAC,oBAAoB,KAAK;AAAA,EAC1B,CAAC,uBAAuB,KAAK;AAAA,EAC7B,CAAC,6BAA6B,KAAK;AAAA,EACnC,CAAC,6BAA6B,KAAK;AAAA;AAAA,EAGnC,CAAC,2BAA2B,EAAE;AAAA,EAC9B,CAAC,+BAA+B,KAAK;AAAA,EACrC,CAAC,6BAA6B,KAAK;AAAA,EACnC,CAAC,gCAAgC,KAAK;AAAA,EACtC,CAAC,4BAA4B,MAAM;AAAA,EACnC,CAAC,yBAAyB,OAAO;AAAA;AAAA,EAGjC,CAAC,qBAAqB,KAAK;AAAA,EAC3B,CAAC,4BAA4B,MAAM;AAAA,EACnC,CAAC,4BAA4B,KAAK;AAAA,EAClC,CAAC,4BAA4B,SAAS;AAAA,EACtC,CAAC,+BAA+B,QAAQ;AAAA,EACxC,CAAC,wBAAwB,KAAK;AAAA,EAC9B,CAAC,2BAA2B,IAAI;AAAA,EAChC,CAAC,yBAAyB,KAAK;AAAA,EAC/B,CAAC,wBAAwB,OAAO;AAAA,EAChC,CAAC,mBAAmB,KAAK;AAAA;AAAA,EAGzB,CAAC,6BAA6B,SAAS;AAAA,EACvC,CAAC,yBAAyB,MAAM;AAAA,EAChC,CAAC,qBAAqB,MAAM;AAAA,EAC5B,CAAC,kBAAkB,MAAM;AAAA,EACzB,CAAC,yBAAyB,MAAM;AAAA,EAChC,CAAC,2BAA2B,MAAM;AAAA,EAClC,CAAC,2BAA2B,KAAK;AAAA;AAAA,EAGjC,CAAC,mBAAmB,MAAM;AAAA,EAC1B,CAAC,qBAAqB,MAAM;AAAA,EAC5B,CAAC,qBAAqB,MAAM;AAAA;AAAA,EAG5B,CAAC,iCAAiC,EAAE;AAAA,EACpC,CAAC,iCAAiC,EAAE;AAAA,EACpC,CAAC,0CAA0C,EAAE;AAAA,EAC7C,CAAC,4BAA4B,MAAM;AAAA,EACnC,CAAC,4BAA4B,MAAM;AAAA,EACnC,CAAC,2BAA2B,MAAM;AACpC;AAEO,SAAS,yBAAyB,OAA0C;AACjF,MAAI,SAAS;AACb,MAAI,eAAe;AAEnB,aAAW,CAAC,SAAS,WAAW,KAAK,sBAAsB;AACzD,UAAM,SAAS;AACf,aAAS,OAAO,QAAQ,SAAS,WAAW;AAC5C,QAAI,WAAW,QAAQ;AACrB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;;;ACzEO,SAAS,mBAAmB,OAAe,cAAuB,MAAmC;AAC1G,MAAI,CAAC,aAAa;AAEhB,UAAM,aAAa,MAChB,QAAQ,WAAW,MAAM,EACzB,QAAQ,cAAc,GAAG,EACzB,QAAQ,aAAa,IAAI,EACzB,QAAQ,aAAa,IAAI;AAE5B,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,YAAY,eAAe;AAAA,IAC7B;AAAA,EACF;AAGA,QAAM,QAAQ,MAAM,MAAM,IAAI;AAC9B,QAAM,SAAmB,CAAC;AAC1B,MAAI,UAAU;AACd,MAAI,aAAa;AAEjB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,OAAO,MAAM,CAAC;AACpB,UAAM,UAAU,KAAK,KAAK;AAE1B,QAAI,QAAQ,WAAW,KAAK,GAAG;AAC7B,UAAI,CAAC,SAAS;AAEZ,YAAI,OAAO,SAAS,GAAG;AACrB,gBAAM,OAAO,OAAO,OAAO,SAAS,CAAC;AACrC,iBAAO,OAAO,SAAS,CAAC,IAAI,uBAAuB,IAAI;AAAA,QACzD;AACA,qBAAa,OAAO;AAAA,MACtB;AACA,gBAAU,CAAC;AACX,aAAO,KAAK,IAAI;AAChB;AAAA,IACF;AAEA,QAAI,SAAS;AAEX,aAAO,KAAK,IAAI;AAChB;AAAA,IACF;AAGA,UAAM,aAAa,uBAAuB,IAAI;AAG9C,UAAM,gBAAgB,kBAAkB,UAAU;AAClD,WAAO,KAAK,aAAa;AAAA,EAC3B;AAGA,QAAM,QAAkB,CAAC;AACzB,MAAI,eAAe;AAEnB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,OAAO,OAAO,CAAC;AACrB,UAAM,UAAU,KAAK,KAAK,EAAE,WAAW;AAEvC,QAAI,WAAW,cAAc;AAC3B;AAAA,IACF;AAEA,UAAM,KAAK,IAAI;AACf,mBAAe;AAAA,EACjB;AAEA,QAAM,SAAS,MAAM,KAAK,IAAI;AAC9B,SAAO;AAAA,IACL;AAAA,IACA,YAAY,WAAW;AAAA,EACzB;AACF;AAEA,SAAS,uBAAuB,MAAsB;AACpD,SAAO,KACJ,QAAQ,cAAc,GAAG,EACzB,QAAQ,WAAW,EAAE,EACrB,QAAQ,WAAW,EAAE;AAC1B;AAEA,SAAS,kBAAkB,MAAsB;AAE/C,QAAM,QAAQ,KAAK,MAAM,YAAY;AACrC,QAAM,SAAmB,CAAC;AAE1B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,OAAO,MAAM,CAAC;AACpB,QAAI,KAAK,WAAW,GAAG,KAAK,KAAK,SAAS,GAAG,GAAG;AAE9C,aAAO,KAAK,IAAI;AAAA,IAClB,OAAO;AAEL,aAAO,KAAK,uBAAuB,IAAI,CAAC;AAAA,IAC1C;AAAA,EACF;AAEA,SAAO,OAAO,KAAK,EAAE;AACvB;;;ACpGO,SAAS,yBAAyB,OAAyC;AAEhF,QAAM,aAAa,MAAM,MAAM,SAAS;AACxC,QAAM,gBAAgB,oBAAI,IAAY;AACtC,QAAM,mBAA6B,CAAC;AACpC,MAAI,oBAAoB;AAExB,aAAW,aAAa,YAAY;AAElC,UAAM,YAAY,UAAU,MAAM,gBAAgB;AAClD,UAAM,kBAA4B,CAAC;AAEnC,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK,GAAG;AAC5C,YAAM,WAAW,UAAU,CAAC;AAC5B,YAAM,cAAc,UAAU,IAAI,CAAC,KAAK;AAExC,UAAI,CAAC,YAAY,SAAS,KAAK,EAAE,WAAW,GAAG;AAC7C,YAAI,YAAa,iBAAgB,KAAK,WAAW;AACjD;AAAA,MACF;AAGA,YAAM,aAAa,kBAAkB,QAAQ;AAG7C,UAAI,WAAW,SAAS,MAAM,CAAC,cAAc,IAAI,UAAU,GAAG;AAC5D,sBAAc,IAAI,UAAU;AAC5B,wBAAgB,KAAK,WAAW,WAAW;AAAA,MAC7C,WAAW,WAAW,SAAS,IAAI;AACjC;AAAA,MACF;AAAA,IACF;AAEA,UAAM,kBAAkB,gBAAgB,KAAK,EAAE;AAC/C,QAAI,gBAAgB,KAAK,EAAE,SAAS,GAAG;AACrC,uBAAiB,KAAK,eAAe;AAAA,IACvC;AAAA,EACF;AAEA,SAAO;AAAA,IACL,QAAQ,iBAAiB,KAAK,MAAM;AAAA,IACpC;AAAA,EACF;AACF;AAKO,SAAS,0BAA0B,OAAyC;AACjF,QAAM,aAAa,MAAM,MAAM,SAAS;AACxC,QAAM,OAAO,oBAAI,IAAY;AAC7B,QAAM,SAAmB,CAAC;AAC1B,MAAI,oBAAoB;AAExB,aAAW,aAAa,YAAY;AAClC,UAAM,aAAa,mBAAmB,SAAS;AAE/C,QAAI,WAAW,SAAS,MAAM,CAAC,KAAK,IAAI,UAAU,GAAG;AACnD,WAAK,IAAI,UAAU;AACnB,aAAO,KAAK,SAAS;AAAA,IACvB,WAAW,WAAW,SAAS,IAAI;AACjC;AAAA,IACF,OAAO;AAEL,aAAO,KAAK,SAAS;AAAA,IACvB;AAAA,EACF;AAEA,SAAO;AAAA,IACL,QAAQ,OAAO,KAAK,MAAM;AAAA,IAC1B;AAAA,EACF;AACF;AAKO,SAAS,iBAAiB,OAAyC;AAExE,QAAM,kBAAkB,0BAA0B,KAAK;AAGvD,QAAM,iBAAiB,yBAAyB,gBAAgB,MAAM;AAEtE,SAAO;AAAA,IACL,QAAQ,eAAe;AAAA,IACvB,mBAAmB,gBAAgB,oBAAoB,eAAe;AAAA,EACxE;AACF;AAEA,SAAS,kBAAkB,UAA0B;AACnD,SAAO,SACJ,YAAY,EACZ,KAAK,EACL,QAAQ,YAAY,EAAE,EACtB,QAAQ,QAAQ,GAAG;AACxB;AAEA,SAAS,mBAAmB,WAA2B;AACrD,SAAO,UACJ,YAAY,EACZ,KAAK,EACL,QAAQ,QAAQ,GAAG,EACnB,QAAQ,QAAQ,GAAG;AACxB;;;AChGO,SAAS,kBAAkB,OAA2C;AAC3E,QAAM,WAAW,uBAAuB,KAAK;AAG7C,QAAM,QAAQ,SAAS,YAAY,SAAS,aAAa,SAAS;AAClE,QAAM,cAAc,QAAQ,IAAI,SAAS,YAAY,QAAQ;AAC7D,QAAM,eAAe,QAAQ,IAAI,SAAS,aAAa,QAAQ;AAC/D,QAAM,cAAc,QAAQ,IAAI,SAAS,YAAY,QAAQ;AAG7D,MAAI,OAAoB;AACxB,MAAI,aAAa;AAEjB,MAAI,cAAc,KAAK;AACrB,WAAO;AACP,iBAAa;AAAA,EACf,WAAW,SAAS,cAAc,GAAG;AACnC,WAAO;AACP,iBAAa,KAAK,IAAI,KAAK,MAAM,SAAS,cAAc,EAAE;AAAA,EAC5D,WAAW,cAAc,KAAK;AAC5B,WAAO;AACP,iBAAa,KAAK,IAAI,KAAK,MAAM,WAAW;AAAA,EAC9C,WAAW,SAAS,cAAc,KAAK,eAAe,KAAK;AACzD,WAAO;AACP,iBAAa,KAAK,IAAI,MAAM,MAAM,SAAS,cAAc,EAAE;AAAA,EAC7D,WAAW,eAAe,KAAK;AAC7B,WAAO;AACP,iBAAa,KAAK,IAAI,KAAK,MAAM,YAAY;AAAA,EAC/C;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,UAAU;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa,SAAS;AAAA,MACtB,aAAa,SAAS;AAAA,IACxB;AAAA,EACF;AACF;AAEA,SAAS,uBAAuB,OAM9B;AACA,MAAI,YAAY;AAChB,MAAI,aAAa;AACjB,MAAI,YAAY;AAChB,MAAI,cAAc;AAClB,MAAI,cAAc;AAGlB,QAAM,UAAU,MAAM,KAAK;AAC3B,OAAK,QAAQ,WAAW,GAAG,KAAK,QAAQ,WAAW,GAAG,MAAM,QAAQ,SAAS,GAAG,KAAK,QAAQ,SAAS,GAAG,GAAG;AAC1G,QAAI;AACF,WAAK,MAAM,OAAO;AAClB,kBAAY,MAAM;AAClB,aAAO,EAAE,WAAW,GAAG,YAAY,GAAG,WAAW,aAAa,GAAG,aAAa,EAAE;AAAA,IAClF,QAAQ;AAAA,IAER;AAAA,EACF;AAGA,kBAAgB,MAAM,MAAM,0CAA0C,KAAK,CAAC,GAAG;AAC/E,kBAAgB,MAAM,MAAM,qCAAqC,KAAK,CAAC,GAAG;AAC1E,kBAAgB,MAAM,MAAM,4BAA4B,KAAK,CAAC,GAAG;AAGjE,kBAAgB,MAAM,MAAM,cAAc,KAAK,CAAC,GAAG;AACnD,kBAAgB,MAAM,MAAM,iBAAiB,KAAK,CAAC,GAAG;AACtD,kBAAgB,MAAM,MAAM,kBAAkB,KAAK,CAAC,GAAG;AACvD,kBAAgB,MAAM,MAAM,iBAAiB,KAAK,CAAC,GAAG;AAGtD,QAAM,QAAQ,MAAM,MAAM,IAAI;AAC9B,MAAI,cAAc;AAElB,aAAW,QAAQ,OAAO;AACxB,QAAI,KAAK,KAAK,EAAE,WAAW,KAAK,GAAG;AACjC,oBAAc,CAAC;AACf,UAAI,YAAa,cAAa,KAAK;AACnC;AAAA,IACF;AAEA,QAAI,aAAa;AACf,mBAAa,KAAK;AAClB;AAAA,IACF;AAGA,UAAM,kBAAkB,KAAK,MAAM,gBAAgB,KAAK,CAAC,GAAG;AAC5D,UAAM,aAAa,KAAK,MAAM,UAAU,KAAK,CAAC,GAAG;AAEjD,QAAI,iBAAiB,YAAY,KAAK;AACpC,mBAAa,KAAK;AAAA,IACpB,OAAO;AACL,oBAAc,KAAK;AAAA,IACrB;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AC7GO,SAAS,qBACd,OACA,UAAgC,CAAC,GACZ;AACrB,QAAM;AAAA,IACJ,YAAY;AAAA,IACZ,oBAAoB;AAAA,IACpB,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,oBAAoB;AAAA,EACtB,IAAI;AAEJ,QAAM,iBAAiB,wBAAwB,KAAK,EAAE;AAGtD,MAAI,kBAAkB,WAAW;AAC/B,WAAO;AAAA,MACL,QAAQ;AAAA,MACR;AAAA,MACA,kBAAkB;AAAA,MAClB,kBAAkB;AAAA,IACpB;AAAA,EACF;AAGA,QAAM,aAAa,MAAM,MAAM,SAAS;AACxC,QAAM,aAAuB,CAAC;AAG9B,MAAI,aAAa,WAAW,SAAS,GAAG;AACtC,eAAW,KAAK,WAAW,CAAC,CAAC;AAAA,EAC/B;AAGA,QAAM,mBAAmB,aAAa,YAAY,WAAW,SAAS,IAClE,WAAW,MAAM,GAAG,EAAE,IACtB,YACA,WAAW,MAAM,CAAC,IAClB,YAAY,WAAW,SAAS,IAChC,WAAW,MAAM,GAAG,EAAE,IACtB;AAEJ,aAAW,aAAa,kBAAkB;AACxC,UAAM,UAAU,mBAAmB,WAAW,iBAAiB;AAC/D,QAAI,QAAQ,KAAK,EAAE,SAAS,GAAG;AAC7B,iBAAW,KAAK,OAAO;AAAA,IACzB;AAAA,EACF;AAGA,MAAI,YAAY,WAAW,SAAS,GAAG;AACrC,UAAM,UAAU,YAAY,WAAW,SAAS,IAAI,WAAW,SAAS;AACxE,eAAW,KAAK,WAAW,OAAO,CAAC;AAAA,EACrC;AAEA,MAAI,SAAS,oBACT,WAAW,KAAK,MAAM,IACtB,WAAW,KAAK,GAAG;AAGvB,MAAI,gBAAgB,wBAAwB,MAAM,EAAE;AACpD,MAAI,gBAAgB,WAAW;AAC7B,aAAS,mBAAmB,QAAQ,SAAS;AAAA,EAC/C;AAEA,QAAM,mBAAmB,wBAAwB,MAAM,EAAE;AAEzD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,kBAAkB,mBAAmB;AAAA,EACvC;AACF;AAEA,SAAS,mBAAmB,WAAmB,WAA2B;AAExE,QAAM,YAAY,UAAU,MAAM,gBAAgB;AAClD,QAAM,eAAyB,CAAC;AAEhC,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK,GAAG;AAC5C,UAAM,WAAW,UAAU,CAAC;AAC5B,UAAM,cAAc,UAAU,IAAI,CAAC,KAAK;AAExC,QAAI,CAAC,YAAY,SAAS,KAAK,EAAE,SAAS,WAAW;AACnD;AAAA,IACF;AAGA,UAAM,QAAQ,cAAc,QAAQ;AAGpC,QAAI,QAAQ,KAAK;AACf,mBAAa,KAAK,WAAW,WAAW;AAAA,IAC1C;AAAA,EACF;AAGA,MAAI,aAAa,WAAW,KAAK,UAAU,UAAU,GAAG;AACtD,UAAM,QAAQ,UAAU,CAAC;AACzB,UAAM,OAAO,UAAU,UAAU,SAAS,CAAC;AAC3C,QAAI,SAAS,MAAM;AACjB,aAAO,SAAS,UAAU,CAAC,KAAK,MAAM,UAAU,QAAQ,UAAU,UAAU,SAAS,CAAC,KAAK;AAAA,IAC7F;AAAA,EACF;AAEA,SAAO,aAAa,KAAK,GAAG;AAC9B;AAEA,SAAS,cAAc,UAA0B;AAC/C,MAAI,QAAQ;AACZ,QAAM,QAAQ,SAAS,YAAY;AAGnC,QAAM,oBAAoB;AAAA,IACxB;AAAA,IAAa;AAAA,IAAa;AAAA,IAAY;AAAA,IAAO;AAAA,IAAQ;AAAA,IACrD;AAAA,IAAW;AAAA,IAAa;AAAA,IAAgB;AAAA,IAAQ;AAAA,IAChD;AAAA,IAAW;AAAA,IAAQ;AAAA,IAAW;AAAA,IAAS;AAAA,IAAU;AAAA,EACnD;AAEA,aAAW,WAAW,mBAAmB;AACvC,QAAI,MAAM,SAAS,OAAO,GAAG;AAC3B,eAAS;AAAA,IACX;AAAA,EACF;AAGA,WAAS,KAAK,IAAI,KAAK,SAAS,SAAS,GAAG;AAG5C,MAAI,MAAM,KAAK,QAAQ,GAAG;AACxB,aAAS;AAAA,EACX;AAGA,MAAI,SAAS,KAAK,SAAS,KAAK,CAAC,GAAG;AAClC,aAAS;AAAA,EACX;AAEA,SAAO,KAAK,IAAI,GAAK,KAAK;AAC5B;AAEA,SAAS,mBAAmB,MAAc,WAA2B;AAEnE,QAAM,aAAa,KAChB,QAAQ,0DAA0D,EAAE,EACpE,QAAQ,QAAQ,GAAG,EACnB,KAAK;AAER,QAAM,SAAS,wBAAwB,UAAU,EAAE;AAEnD,MAAI,UAAU,WAAW;AACvB,WAAO;AAAA,EACT;AAGA,QAAM,QAAQ,YAAY;AAC1B,QAAM,eAAe,KAAK,MAAM,KAAK,SAAS,QAAQ,GAAG;AACzD,SAAO,KAAK,UAAU,GAAG,YAAY,IAAI;AAC3C;;;ACvKO,SAAS,aAAa,SAA4C;AACvE,QAAM,iBAAiB,KAAK,KAAK,QAAQ,SAAS,CAAC;AAEnD,MAAI,YAAY;AAGhB,cAAY,UAAU,QAAQ,4EAA4E,EAAE;AAC5G,cAAY,UAAU,QAAQ,gDAAgD,EAAE;AAChF,cAAY,UAAU,QAAQ,4CAA4C,EAAE;AAG5E,cAAY,UAAU,QAAQ,0CAA0C,EAAE;AAG1E,QAAM,QAAQ,UAAU,MAAM,IAAI;AAClC,QAAM,eAAe,oBAAI,IAAoB;AAC7C,QAAM,aAAuB,CAAC;AAE9B,aAAW,QAAQ,OAAO;AACxB,UAAM,aAAa,KAAK,YAAY,EAAE,KAAK;AAC3C,QAAI,WAAW,SAAS,IAAI;AAC1B,YAAM,QAAQ,aAAa,IAAI,UAAU,KAAK;AAC9C,mBAAa,IAAI,YAAY,QAAQ,CAAC;AAEtC,UAAI,UAAU,GAAG;AACf,mBAAW,KAAK,IAAI;AAAA,MACtB,WAAW,UAAU,GAAG;AACtB,mBAAW,KAAK,aAAa,QAAQ,CAAC,MAAM,IAAI,EAAE;AAAA,MACpD,OAAO;AAEL,cAAM,UAAU,WAAW,SAAS;AACpC,YAAI,WAAW,OAAO,EAAE,WAAW,WAAW,GAAG;AAC/C,qBAAW,OAAO,IAAI,aAAa,QAAQ,CAAC,MAAM,IAAI;AAAA,QACxD;AAAA,MACF;AAAA,IACF,OAAO;AACL,iBAAW,KAAK,IAAI;AAAA,IACtB;AAAA,EACF;AAEA,cAAY,WAAW,KAAK,IAAI;AAGhC,cAAY,UAAU,QAAQ,WAAW,MAAM;AAE/C,QAAM,kBAAkB,KAAK,KAAK,UAAU,SAAS,CAAC;AACtD,QAAM,iBAAiB,iBAAiB,KAClC,iBAAiB,mBAAmB,iBAAkB,MACxD;AAEJ,SAAO;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA,gBAAgB,KAAK,MAAM,iBAAiB,GAAG,IAAI;AAAA,EACrD;AACF;AAKO,SAAS,sBAAsB,SAA4C;AAChF,QAAM,iBAAiB,KAAK,KAAK,QAAQ,SAAS,CAAC;AAEnD,MAAI,YAAY;AAGhB,cAAY,UAAU,QAAQ,uDAAuD,EAAE;AACvF,cAAY,UAAU,QAAQ,2DAA2D,EAAE;AAG3F,cAAY,UAAU,QAAQ,kEAAkE,OAAO;AAGvG,cAAY,UAAU,QAAQ,qBAAqB,WAAW;AAG9D,QAAM,iBAAiB,UAAU,MAAM,0BAA0B;AACjE,MAAI,kBAAkB,eAAe,SAAS,GAAG;AAC/C,gBAAY,UAAU,QAAQ,mCAAmC,EAAE;AAAA,EACrE;AAGA,cAAY,UAAU,QAAQ,WAAW,QAAQ;AAEjD,QAAM,kBAAkB,KAAK,KAAK,UAAU,SAAS,CAAC;AACtD,QAAM,iBAAiB,iBAAiB,KAClC,iBAAiB,mBAAmB,iBAAkB,MACxD;AAEJ,SAAO;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA,gBAAgB,KAAK,MAAM,iBAAiB,GAAG,IAAI;AAAA,EACrD;AACF;AAKO,SAAS,qBAAqB,UAA6C;AAChF,QAAM,iBAAiB,KAAK,KAAK,SAAS,SAAS,CAAC;AAEpD,MAAI,YAAY;AAChB,QAAM,QAAQ,UAAU,MAAM,IAAI;AAClC,QAAM,SAAmB,CAAC;AAE1B,aAAW,QAAQ,OAAO;AAExB,UAAM,UAAU,KAAK,KAAK;AAC1B,UAAM,YAAY,QAAQ,WAAW,IAAI,KAAK,QAAQ,WAAW,IAAI,KAAK,QAAQ,WAAW,GAAG;AAEhG,QAAI,CAAC,WAAW;AACd,aAAO,KAAK,IAAI;AAChB;AAAA,IACF;AAGA,UAAM,cAAc,QAAQ,QAAQ,oCAAoC,EAAE,EAAE,YAAY;AAGxF,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,IACF;AAEA,UAAM,YAAY,gBAAgB,KAAK,aAAW,QAAQ,KAAK,WAAW,CAAC;AAE3E,QAAI,CAAC,aAAa,YAAY,SAAS,IAAI;AAEzC,aAAO,KAAK,IAAI;AAAA,IAClB;AAAA,EAEF;AAEA,cAAY,OAAO,KAAK,IAAI;AAG5B,cAAY,UAAU,QAAQ,WAAW,MAAM;AAE/C,QAAM,kBAAkB,KAAK,KAAK,UAAU,SAAS,CAAC;AACtD,QAAM,iBAAiB,iBAAiB,KAClC,iBAAiB,mBAAmB,iBAAkB,MACxD;AAEJ,SAAO;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA,gBAAgB,KAAK,MAAM,iBAAiB,GAAG,IAAI;AAAA,EACrD;AACF;;;ACjKA,IAAM,WAAN,MAAqB;AAAA,EACX;AAAA,EACA;AAAA,EAER,YAAY,UAAkB,KAAM;AAClC,SAAK,QAAQ,oBAAI,IAAI;AACrB,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,IAAI,KAAuB;AACzB,QAAI,CAAC,KAAK,MAAM,IAAI,GAAG,GAAG;AACxB,aAAO;AAAA,IACT;AAGA,UAAM,QAAQ,KAAK,MAAM,IAAI,GAAG;AAChC,SAAK,MAAM,OAAO,GAAG;AACrB,SAAK,MAAM,IAAI,KAAK,KAAK;AAEzB,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,KAAiB;AACtB,WAAO,KAAK,MAAM,OAAO,GAAG;AAAA,EAC9B;AAAA,EAEA,IAAI,KAAiB;AACnB,WAAO,KAAK,MAAM,IAAI,GAAG;AAAA,EAC3B;AAAA,EAEA,IAAI,KAAQ,OAAgB;AAC1B,QAAI,KAAK,MAAM,IAAI,GAAG,GAAG;AAEvB,WAAK,MAAM,OAAO,GAAG;AAAA,IACvB,WAAW,KAAK,MAAM,QAAQ,KAAK,SAAS;AAE1C,YAAM,WAAW,KAAK,MAAM,KAAK,EAAE,KAAK,EAAE;AAC1C,UAAI,aAAa,QAAW;AAC1B,aAAK,MAAM,OAAO,QAAQ;AAAA,MAC5B;AAAA,IACF;AAEA,SAAK,MAAM,IAAI,KAAK,KAAK;AAAA,EAC3B;AAAA,EAEA,QAAc;AACZ,SAAK,MAAM,MAAM;AAAA,EACnB;AAAA,EAEA,OAAe;AACb,WAAO,KAAK,MAAM;AAAA,EACpB;AACF;AAGA,IAAM,oBAAoB,IAAI,SAA6B,GAAI;AAC/D,IAAM,YAAY;AAKX,SAAS,gBAAgB,OAAkC;AAChE,QAAM,SAAS,kBAAkB,IAAI,KAAK;AAC1C,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AAGA,QAAM,MAAM,KAAK,IAAI,IAAI,OAAO;AAChC,MAAI,MAAM,WAAW;AACnB,sBAAkB,OAAO,KAAK;AAC9B,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAKO,SAAS,YAAY,OAAe,QAAgB,QAAsB;AAC/E,oBAAkB,IAAI,OAAO;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,WAAW,KAAK,IAAI;AAAA,EACtB,CAAC;AACH;AAKO,SAAS,aAAmB;AACjC,oBAAkB,MAAM;AAC1B;AAKO,SAAS,gBAAmD;AACjE,SAAO;AAAA,IACL,MAAM,kBAAkB,KAAK;AAAA,IAC7B,SAAS;AAAA,EACX;AACF;AAMO,SAAS,yBAAyB,MAAuB;AAE9D,QAAM,gBAAgB;AACtB,MAAI,cAAc,KAAK,IAAI,GAAG;AAC5B,WAAO;AAAA,EACT;AAGA,QAAM,iBAAiB;AACvB,MAAI,eAAe,KAAK,IAAI,GAAG;AAC7B,WAAO;AAAA,EACT;AAGA,MAAI,SAAS,KAAK,IAAI,KAAK,YAAY,KAAK,IAAI,GAAG;AACjD,WAAO;AAAA,EACT;AAGA,QAAM,YAAY,KAAK,MAAM,WAAW;AACxC,QAAM,OAAO,oBAAI,IAAY;AAC7B,aAAW,YAAY,WAAW;AAChC,UAAM,aAAa,SAAS,YAAY,EAAE,KAAK;AAC/C,QAAI,WAAW,SAAS,MAAM,KAAK,IAAI,UAAU,GAAG;AAClD,aAAO;AAAA,IACT;AACA,SAAK,IAAI,UAAU;AAAA,EACrB;AAEA,SAAO;AACT;;;AC5GO,SAAS,iBACd,OACA,UAAuC,CAAC,GACZ;AAE5B,QAAM,WAAW,KAAK,UAAU,EAAE,OAAO,QAAQ,CAAC;AAClD,QAAM,SAAS,gBAAgB,QAAQ;AACvC,MAAI,QAAQ;AACV,WAAO;AAAA,MACL,QAAQ,OAAO;AAAA,MACf,gBAAgB,wBAAwB,KAAK,EAAE;AAAA,MAC/C,iBAAiB,OAAO;AAAA,MACxB,OAAO,wBAAwB,KAAK,EAAE,SAAS,OAAO;AAAA,MACtD,gBAAgB,wBAAwB,KAAK,EAAE,SAAS,KAClD,wBAAwB,KAAK,EAAE,SAAS,OAAO,UAAU,wBAAwB,KAAK,EAAE,SAAU,MACpG;AAAA,MACJ,YAAY,CAAC,QAAQ;AAAA,MACrB,aAAa,kBAAkB,KAAK,EAAE;AAAA,IACxC;AAAA,EACF;AAGA,MAAI,CAAC,yBAAyB,KAAK,GAAG;AACpC,UAAM,SAAS,wBAAwB,KAAK,EAAE;AAC9C,gBAAY,UAAU,OAAO,MAAM;AACnC,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,MACjB,OAAO;AAAA,MACP,gBAAgB;AAAA,MAChB,YAAY,CAAC;AAAA,MACb,aAAa,kBAAkB,KAAK,EAAE;AAAA,IACxC;AAAA,EACF;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,4BAA4B;AAAA,IAC5B,8BAA8B;AAAA,IAC9B,yBAAyB;AAAA,IACzB,sBAAsB;AAAA,IACtB,4BAA4B;AAAA,IAC5B,aAAa;AAAA,EACf,IAAI;AAEJ,QAAM,iBAAiB,wBAAwB,KAAK,EAAE;AACtD,QAAM,eAAe,uBACjB,KAAK,MAAM,kBAAkB,IAAI,uBAAuB,IAAI,IAC5D,aAAa;AAEjB,MAAI,SAAS;AACb,QAAM,aAAuB,CAAC;AAG9B,QAAM,YAAY,kBAAkB,MAAM;AAC1C,QAAM,cAAc,uBAAuB,UAAU;AAGrD,MAAI,2BAA2B;AAC7B,QAAI;AACJ,YAAQ,aAAa;AAAA,MACnB,KAAK;AACH,wBAAgB,aAAa,MAAM;AACnC,YAAI,cAAc,iBAAiB,GAAG;AACpC,mBAAS,cAAc;AACvB,qBAAW,KAAK,kBAAkB;AAAA,QACpC;AACA;AAAA,MACF,KAAK;AACH,wBAAgB,sBAAsB,MAAM;AAC5C,YAAI,cAAc,iBAAiB,GAAG;AACpC,mBAAS,cAAc;AACvB,qBAAW,KAAK,kBAAkB;AAAA,QACpC;AACA;AAAA,MACF,KAAK;AACH,wBAAgB,qBAAqB,MAAM;AAC3C,YAAI,cAAc,iBAAiB,GAAG;AACpC,mBAAS,cAAc;AACvB,qBAAW,KAAK,2BAA2B;AAAA,QAC7C;AACA;AAAA,IACJ;AAGA,UAAM,gBAAgB,wBAAwB,MAAM,EAAE;AACtD,QAAI,iBAAiB,cAAc;AACjC,aAAO;AAAA,QACL,QAAQ;AAAA,QACR;AAAA,QACA,iBAAiB;AAAA,QACjB,OAAO,iBAAiB;AAAA,QACxB,gBAAgB,iBAAiB,KAAM,iBAAiB,iBAAiB,iBAAkB,MAAM;AAAA,QACjG;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,MAAI,wBAAwB;AAC1B,UAAM,kBAAkB,iBAAiB,MAAM;AAC/C,QAAI,gBAAgB,oBAAoB,GAAG;AACzC,eAAS,gBAAgB;AACzB,iBAAW,KAAK,mBAAmB;AAEnC,YAAM,gBAAgB,wBAAwB,MAAM,EAAE;AACtD,UAAI,iBAAiB,cAAc;AACjC,eAAO,aAAa,QAAQ,gBAAgB,YAAY,WAAW;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AAGA,MAAI,2BAA2B;AAC7B,UAAM,iBAAiB,yBAAyB,MAAM;AACtD,QAAI,eAAe,eAAe,GAAG;AACnC,eAAS,eAAe;AACxB,iBAAW,KAAK,sBAAsB;AAEtC,YAAM,gBAAgB,wBAAwB,MAAM,EAAE;AACtD,UAAI,iBAAiB,cAAc;AACjC,eAAO,aAAa,QAAQ,gBAAgB,YAAY,WAAW;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AAGA,QAAM,UAAoB,CAAC,gBAAgB,YAAY,cAAc,OAAO;AAC5E,MAAI,cAAc,QAAQ,QAAQ,MAAM;AAExC,WAAS,IAAI,aAAa,IAAI,QAAQ,QAAQ,KAAK;AACjD,UAAM,cAAc,aAAa,QAAQ,EAAE,QAAQ,QAAQ,CAAC,EAAE,CAAC;AAC/D,QAAI,YAAY,KAAK,SAAS;AAC5B,eAAS,YAAY;AACrB,UAAI,CAAC,WAAW,SAAS,eAAe,GAAG;AACzC,mBAAW,KAAK,iBAAiB,QAAQ,CAAC,CAAC,EAAE;AAAA,MAC/C,OAAO;AAEL,cAAM,MAAM,WAAW,UAAU,OAAK,EAAE,WAAW,eAAe,CAAC;AACnE,mBAAW,GAAG,IAAI,iBAAiB,QAAQ,CAAC,CAAC;AAAA,MAC/C;AAEA,YAAM,gBAAgB,wBAAwB,MAAM,EAAE;AACtD,UAAI,iBAAiB,cAAc;AACjC,eAAO,aAAa,QAAQ,gBAAgB,YAAY,WAAW;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AAGA,MAAI,6BAA6B;AAC/B,UAAM,mBAAmB,mBAAmB,QAAQ,IAAI;AACxD,QAAI,iBAAiB,YAAY;AAC/B,eAAS,iBAAiB;AAC1B,iBAAW,KAAK,wBAAwB;AAExC,YAAM,gBAAgB,wBAAwB,MAAM,EAAE;AACtD,UAAI,iBAAiB,cAAc;AACjC,eAAO,aAAa,QAAQ,gBAAgB,YAAY,WAAW;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AAGA,MAAI,uBAAuB,iBAAiB,KAAO;AACjD,UAAM,gBAAgB,qBAAqB,QAAQ;AAAA,MACjD,WAAW;AAAA,MACX,mBAAmB;AAAA,MACnB,WAAW;AAAA,MACX,UAAU;AAAA,IACZ,CAAC;AAED,QAAI,cAAc,mBAAmB,GAAK;AACxC,eAAS,cAAc;AACvB,iBAAW,KAAK,eAAe;AAAA,IACjC;AAAA,EACF;AAEA,QAAM,cAAc,aAAa,QAAQ,gBAAgB,YAAY,WAAW;AAGhF,cAAY,UAAU,YAAY,QAAQ,YAAY,eAAe;AAErE,SAAO;AACT;AAEA,SAAS,aACP,QACA,gBACA,YACA,aAC4B;AAC5B,QAAM,kBAAkB,wBAAwB,MAAM,EAAE;AACxD,QAAM,QAAQ,iBAAiB;AAC/B,QAAM,iBAAiB,iBAAiB,IACnC,QAAQ,iBAAkB,MAC3B;AAEJ,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,gBAAgB,KAAK,MAAM,iBAAiB,GAAG,IAAI;AAAA,IACnD;AAAA,IACA;AAAA,EACF;AACF;;;ACrPA,SAAS,UAAU,MAAgB;AACjC,QAAM,OAAyC,CAAC;AAChD,QAAM,OAAiB,CAAC;AACxB,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,IAAI,KAAK,CAAC;AAChB,QAAI,EAAE,WAAW,IAAI,GAAG;AACtB,YAAM,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG;AACnC,WAAK,CAAC,IAAI,KAAK;AAAA,IACjB,WAAW,EAAE,WAAW,GAAG,GAAG;AAC5B,WAAK,EAAE,MAAM,CAAC,CAAC,IAAI;AAAA,IACrB,OAAO;AACL,WAAK,KAAK,CAAC;AAAA,IACb;AAAA,EACF;AACA,SAAO,EAAE,KAAK,KAAK,MAAM,KAAK,IAAI,MAAM,KAAK;AAC/C;AAEA,SAAS,YAAY,MAAc,KAAc;AAC/C,MAAI,OAAO,OAAO,QAAQ,SAAU,eAAc,KAAK,IAAI;AAAA,MACtD,SAAQ,OAAO,MAAM,IAAI;AAChC;AAEA,eAAsB,KAAK,OAAiB,QAAQ,KAAK,MAAM,CAAC,GAAG;AACjE,QAAM,EAAE,KAAK,MAAM,KAAK,IAAI,UAAU,IAAI;AAC1C,MAAI,KAAK,KAAK,KAAK,SAAS;AAC1B,UAAM,MAAM,MAAM,OAAO,uBAAoD,EAAE,MAAM,OAAO,EAAE,SAAS,EAAE,SAAS,QAAQ,EAAE,EAAE;AAC9H,YAAQ,IAAI,IAAI,QAAQ,OAAO;AAC/B,WAAO;AAAA,EACT;AAEA,MAAI;AACF,QAAI,QAAQ,eAAe;AACzB,YAAM,QAAQ,KAAK,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,IAAI,cAAc;AAC9D,YAAM,MAAM,WAAW,OAAO,EAAE,SAAS,CAAC,CAAC,KAAK,UAAU,GAAG,UAAU,OAAU,CAAC;AAClF,kBAAY,IAAI,SAAS,MAAM,KAAK,GAAyB;AAC7D,UAAI,KAAK,QAAQ;AACf,cAAM,SAAS,wBAAwB,KAAK;AAC5C,cAAM,QAAQ,wBAAwB,IAAI,MAAM;AAChD,gBAAQ,MAAM,KAAK,UAAU,EAAE,MAAM,eAAe,QAAQ,MAAM,CAAC,CAAC;AAAA,MACtE;AACA,aAAO;AAAA,IACT;AACA,QAAI,QAAQ,QAAQ;AAClB,YAAM,SAAS,KAAK,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,IAAI,cAAc;AAC/D,YAAM,QAAQ,KAAK,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,IAAI;AAChD,YAAM,QAAQ,YAAY,UAAU,QAAQ,SAAS,OAAO,EAAE,SAAS,CAAC,CAAC,KAAK,UAAU,EAAE,CAAC;AAC3F,kBAAY,OAAO,KAAK,GAAyB;AACjD,UAAI,KAAK,QAAQ;AACf,cAAM,IAAI,wBAAwB,QAAQ,EAAE,mBAAmB,KAAK,CAAC;AACrE,cAAM,IAAI,wBAAwB,OAAO,EAAE,mBAAmB,KAAK,CAAC;AACpE,gBAAQ,MAAM,KAAK,UAAU,EAAE,MAAM,QAAQ,QAAQ,GAAG,OAAO,EAAE,CAAC,CAAC;AAAA,MACrE;AACA,aAAO;AAAA,IACT;AACA,QAAI,QAAQ,iBAAiB;AAC3B,YAAM,QAAQ,KAAK,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,IAAI,cAAc;AAC9D,YAAM,SAAU,KAAK,UAAqB;AAC1C,YAAM,MAAM,aAAa,OAAO,EAAE,QAAuB,SAAS,CAAC,CAAC,KAAK,UAAU,EAAE,CAAC;AACtF,kBAAY,IAAI,SAAS,MAAM,KAAK,GAAyB;AAC7D,UAAI,KAAK,QAAQ;AACf,cAAM,SAAS,wBAAwB,KAAK;AAC5C,cAAM,QAAQ,wBAAwB,IAAI,MAAM;AAChD,gBAAQ,MAAM,KAAK,UAAU,EAAE,MAAM,iBAAiB,QAAQ,MAAM,CAAC,CAAC;AAAA,MACxE;AACA,aAAO;AAAA,IACT;AACA,QAAI,QAAQ,cAAc,QAAQ,YAAY;AAC5C,YAAM,QAAQ,KAAK,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,IAAI,cAAc;AAC9D,YAAM,UAAuC;AAAA,QAC3C,QAAS,KAAK,UAAkB;AAAA,QAChC,sBAAsB,KAAK,gBAAgB,IAAI,WAAW,KAAK,gBAAgB,CAAW,IAAI;AAAA,QAC9F,WAAW,KAAK,YAAY,IAAI,SAAS,KAAK,YAAY,GAAa,EAAE,IAAI;AAAA,QAC7E,2BAA2B,KAAK,aAAa,MAAM;AAAA,QACnD,6BAA6B,KAAK,eAAe,MAAM;AAAA,QACvD,wBAAwB,KAAK,eAAe,MAAM;AAAA,QAClD,qBAAqB,KAAK,kBAAkB,MAAM;AAAA,QAClD,2BAA2B,KAAK,YAAY,MAAM;AAAA,MACpD;AACA,YAAM,MAAM,iBAAiB,OAAO,OAAO;AAC3C,kBAAY,IAAI,SAAS,MAAM,KAAK,GAAyB;AAC7D,UAAI,KAAK,QAAQ;AACf,gBAAQ,MAAM,KAAK,UAAU;AAAA,UAC3B,MAAM;AAAA,UACN,QAAQ,EAAE,QAAQ,IAAI,eAAe;AAAA,UACrC,OAAO,EAAE,QAAQ,IAAI,gBAAgB;AAAA,UACrC,OAAO,IAAI;AAAA,UACX,gBAAgB,IAAI;AAAA,UACpB,YAAY,IAAI;AAAA,UAChB,aAAa,IAAI;AAAA,QACnB,CAAC,CAAC;AAAA,MACJ;AACA,aAAO;AAAA,IACT;AACA,YAAQ,MAAM,gJAAgJ;AAC9J,WAAO;AAAA,EACT,SAAS,GAAG;AACV,UAAM,MAAO,EAAY,WAAW,OAAO,CAAC;AAC5C,UAAM,OAAQ,GAAW,SAAS,IAAI,IAAI;AAC1C,YAAQ,MAAM,GAAG;AACjB,WAAO;AAAA,EACT;AACF;AAEA,IAAI,YAAY,QAAQ,UAAU,QAAQ,KAAK,CAAC,CAAC,MAAM,QAAQ,KAAK,CAAC,GAAG,SAAS,qBAAqB,GAAG;AAEvG,OAAK,EAAE,KAAK,CAAC,SAAS,QAAQ,KAAK,IAAI,CAAC,EAAE,MAAM,CAAC,QAAQ;AACvD,YAAQ,MAAM,KAAK,WAAW,OAAO,GAAG,CAAC;AACzC,YAAQ,KAAK,CAAC;AAAA,EAChB,CAAC;AACH;","names":[]}